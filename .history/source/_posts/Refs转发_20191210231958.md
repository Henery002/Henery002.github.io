---
title: Refs转发
date: 2019-06-05 10:00
tags:
---

React中的refs提供了一种访问 render() 方法中创建的React 元素的方法。虽然React的使用思想是通过传入 props 或 state 进行状态管理进而重新渲染组件，不提倡强行修改DOM元素，但在某些场景和需求下，访问DOM节点不可避免，是从DOM元素读取数据的好方法。

## 在React中使用Refs的四种方式

### String refs

ref的字符串属性。
```javascript
<input type="text" ref="textInput" />
```
然后在组件中可以通过 this.refs.textInput.value 获取到该DOM节点的值
这种设置refs的方式已经过时。在配置了eslint的项目中使用时将会抛出错误提示，应该避免使用这个废弃的API。
回调引用（callback refs）
给DOM元素添加ref属性

在项目中常用的方式是refs回调。即为ref属性设置回调函数，当设置ref时，React会调用这个函数，并将element作为第一个参数传递给该函数。
贴一个常用的案例。该示例用于获取input标签的文本值，使用回调函数的方式引入。
class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = null;

    this.setTextInputRef = element => {
      this.textInput = element; // 将element赋值给 this.textInput
    };
  }

  handleSubmit = e => {
    e.preventDefault();
    console.log(this.textInput.value);
  };

  render() {
    return (
      <div>
        <input type="text" ref={this.setTextInputRef} />
        // 或者写成
        <input type="text" ref={ele => this.eleInput = ele}> // ele 即指向当前input元素
        <button onClick={e => this.handleSubmit(e)}>提交</button>
      </div>
    );
  }
}
当组件被挂载时React会将这个DOM元素传递给 ref 的回调函数，element作为DOM元素的实例被赋值给 this.textInput。

给类组件添加ref属性
如果给 class 声明的组件添加 ref 属性，则 ref 回调的参数将指向已经加载的该组件的实例。这种方式区别于下面将要讲到的函数式组件。
class Foo extends React.Component {
  render() {
    return <input type="text" />;
  }
}

class Fn extentds React.Comonent {
  render() {
    return <Foo ref={ele => { this.componentEle = ele; console.log(ele) }} />;   // ele指向当前组件的实例
  }
}

refs与函数式组件
ref属性不能用在函数式声明的组件上，因为函数式组件不能被实例化。如以下ref赋值方式无效并且会报错：
function InputText() {
  return (
    <div>
      <input type="text"/>
    </div>
  );
}

class MyComponent extends React.Component {
  render() {
    // ref 无效且报错
    return <InputText ref = {el => {this.componEle = el}}/>
  }
}
但是在函数式组件内部依然可以使用ref属性。

React.createRef()
React提供了creatRef()函数来创建Refs，并通过该方法将ref属性附加到React组件的DOM元素上。
比如，我们在组件的构造函数中创建一个ref实例，使其在整个组件内可用，并将其赋值给 this.firstRef，然后在render()方法内部，将创建的ref示例传递给HTML元素。
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.firstRef = React.createRef();
  }
  // ...
  render() {
    return <div ref={this.firstRef} />;
  }
}
通过这种方式创建ref，我们可以重构一些现有的业务场景。
来看一个例子：
class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);
    // 创建一个ref实例
    this.textInput = React.createRef();
  }

  focusTextInput() {
    // 当 ref 属性被render()方法中的HTML元素使用时，上述创建的ref实例会接收来自底层DOM元素的 current 值
    console.log(this.textInput.current.value);
    this.textInput.current.focus();
  }

  render() {
    // 将在构造函数中创建的ref示例传递到 input 组件的 ref 属性上
    return (
      <div>
        <input type="text" ref={this.textInput} />

        <input
          type="button"
          value="Focus the text input"
          onClick={this.focusTextInput}
        />
      </div>
    );
  }
}
这里有一个 current 属性，它就是input DOM 元素对象本身（是一个DOM对象），所以，要获取input标签的实际值（或者其方法属性），必须要使用 this.textInput.current.value 方式。
React.createRef 主要是结合 React.forwardRef 方法实现 refs 的转发，来看下面的例子。
转发refs（Forwarding refs）
React提供的 Ref forwarding 方案用来将 ref 通过组件传递给其子节点。这种场景对于可复用组件库和高阶组件很有用。
也就是说，可以使用 React.forwardRef 函数将 ref 转发到组件中，Ref forwarding 允许组件接收一个 ref，并将它向下传递 / 转发（用来点题）给子组件。
一个栗子：
const TextInput = React.forwardRef((props, ref) => (
  <input type="text" placeholder="请输入表名" ref={ref} />
));
const inputRef = React.createRef();

class CustomTextInput extends React.Component {
   handleSave = () => {
    console.log(inputRef.current.value);
  };

  render() {
    return (
      <div>
        <TextInput ref={inputRef} />
        <button onClick={this.handleSave}>保存</button>
      </div>
    );
  }
}
总结起来说，就是：
使用 React.createRef() 创建一个 ref 实例（inputRef）；
将 ref 实例指定给组件（TextInput）的 ref 属性 ;
React.forwardRef()方法将 ref 实例作为其回调函数的第二个参数向下转发给底层DOM组件（<input ref={ref} />）；
在外层组件中能够通过 current对象访问DOM节点值。
注：这里的外层组件是 CustomTextInput 相对于 InputText 而言。
在高阶组件中转发Refs
另外在React Refs的官方文档中还讲到了在高阶组件（HOC）中转发 refs，这里也顺便了解一下。不过我目前还没有在项目中实际使用过，但对于高阶组件而言很有用。
const Input  = (InputComponent) => {
  const forwardRef = (props, ref) => {
    const onChange = () => console.log(ref.current.value);
    return (
      <InputComponent
        forwardedRef={ref}
        onChange={onChange}
        {...props}
      />
    );
  };
  return React.forwardRef(forwardRef);
};
这个 Input 高阶组件接收一个 InputComponent 组件作为参数，forwardRef 函数会返回 InputComponent，函数中包含的 ref 参数是由 React.forwardRef() 方法创建的。这个高阶组件最终会把包装好的组件作为值返回。
// 待包装子组件 InputCompoment
// 将 forwardedRef 下发给 ref 属性，在render()方法中，input输入框就会接收到这个 ref
const TextInput = ({ forwardedRef, children, ...rest }) => (
  <div>
    <input ref={forwardedRef} {...rest} />
    {children}
  </div>
);
可以这样使用这个高阶组件：
// 将 TextInput 传入 Input 高阶组件，会返回一个 InputField component
const InputField = Input(TextInput);

class CustomTextInput extends React.Component {
  render() {;
    // 依然使用该方法创建一个 ref 实例，并作为参数传递给 InputFIeld 组
    const inputRef = React.createRef();
    return <InputField ref={inputRef} />;
  }
}

小结
refs的实际项目中的使用场景并不是很多，也不是必须要用到的技术点，只是有时候在特定场景下使用将会便于开发（如操作input控件的值与状态改变、触发某些动画等）。
这里只是作为技术复盘，盘点一下React Refs的使用方式，温故而知新。

参考文章
React中文文档 - Refs转发
深入理解React虚拟DOM
React中的Refs & DOM
