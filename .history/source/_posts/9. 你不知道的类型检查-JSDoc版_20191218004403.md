---
title: 你不知道的类型检查[JSDoc版]
date: 2019-11-15 10:00:00
tags:
  - 类型检查
  - JSDoc
---

## JS 的特性

对于前端开发者来说，JsvaScript 是一门弱类型语言，它的类型系统没有强类型语言（Java 等）提供的类型系统复杂和完善，这也就导致了一个必然的问题：需要一些额外的方案为其做类型声明。而为 Javascript 作类型声明也将会是一件比较麻烦的事。

在既有的技术栈范围内以及实战项目中，我们已经接触到了使用 PropTypes、TypeScript 这些静态类型检查器为 js 在进入运行阶段之前作类型检查的方式。

## 类型检查解决方案

- Flow：[官方文档](https://flow.org/en/docs/react/components/)

  - 静态类型检查器，通过一套特属语法为变量、函数、组件提供注解。

- TypeScript：[TypeScript 入门教程](https://ts.xcatliu.com/)

  - JS 的类型超集，作为一种独立的类型语言存在，类型系统复杂强大。

- [PropTypes](https://react.docschina.org/docs/static-type-checking.html)

  - 通过配置 propTypes 属性为组件 props 设置类型检查。

- JSDoc：[技术手册](https://jsdoc.app/tags-class.html)

  - 一个根据 JS 文件的注释信息生成 JS 应用程序或库、模块的 API 文档工具。
  - JSDoc 注释是标准的 JS 注释，使用方便，不需要向 TS 一样需要构建步骤来转换语法，是为 JS 提供类型检查成本最低的方式。

本文关注用 JSDoc 注释实现类型检查。

## 基本配置

1. ### 安装

```javascript
npm install -g jsdoc
```

2. ### 配置生成规则

```json
// jsdoc.json
{
  "source": {
    "include": ["src/"] // 需要生成文档的对应 js 路径
  },
  "opts": {
    "destination": "docs/", // 文档生成目录
    "readme": "docs/index.md", // 文档首页展示内容
    "template": "", // 文档模板，可自行寻找合适的 API 生成模板替换使用
    "encoding": "utf8"
  },
  "templates": {
    // 模板配置，此处跟模板设置有关
  },
  "plugins": ["plugins/markdown"],
  "markdown": {
    "tags": ["example"],
    "idInHeadings": true
  }
}
```

比如一套模板配置项可以为：

```json
{
  "templates": {
    "default": {
      // 可自定义指定添加到 styles 的目录
      "staticFiles": {
        "include": ["./static"]
      }
    },
    "css": [
      "styles/style.css" // 自定义样式
    ],
    "name": "Doc Template", // 文档名称
    "tabNames": {
      // 导航名称
      "tutorials": "wiki",
      "apiName": "api"
    }
  }
}
```

3. ### 3. 生成 API 文档
4. ### VSCode 插件

```json
// settings.json
"javascript.implicitProjectConfig.checkJs": true, //开启类型检查 "
```

## JsDoc 注释

1. ### 打开/关闭类型检查

- @ts-check
- @ts-nocheck
- @ts-ignore
  使用 JSDoc 定义类型
- @type 声明一个类型

```javascript
/**
 * @type {string} address - 地址
 */
const address = "NJ";
```

声明类型的方式和 TypeScript 是一样的，都具有 string、number、undefined、Array、Object 等类型，包括 string[]、Object[]、any[]。同时也可以使用联合类型和交集类型。
在定义类型的时候尽量避免定义 any 类型，最好使用联合类型或者交集类型来代替。

```typescript
/**
 * @type {number | string} page
 */
const page = 12; // or '12'

/**
 * @type {{name: string}, {age: number}} person
 */
const person = {
  name: "TACK",
  age: 22
};
```

@typedef 定义自定义类型，可以为其定义属性

自定义类型在类型被反复使用时很有必要，类似于 TS 中的 interface、type。

```javascript
/**
 * 包含姓名和年龄的对象
 * @typedef {Object<string, any>} Person
 * @property {string} name - 姓名
 * @property {number} [age] - 年龄
 */
/**
 * @type {Person} person
 */
const person = {
  name: "JACK",
  age: 22
};
```

@function 或 @class 定义函数或类方法

定义时需要使用 @param 定义函数参数，使用 @return 定义函数返回值。

```javascript
/**
 * 预览版，编辑（即失焦）、删除自动匹配映射的代码表的值，删除时需要删除掉新增的这一整行
 * @param {{id: number}} record - 该行属性集合
 * @param {number} [idx] - 当前行当前输入框的下标，值为 0/1
 * @param {{}} [fieldsValue] - 表单值集合，用于编辑，不传该值表示删除
 * @return void
 */
getInputAITableChange = (record, idx, fieldsValue) => {
  // ...
};
```

扩展类（Extending Classes）

```javascript
/**
 * Class
 * @extends Point
 */
class Dot extends Point {
  /**
   * Create a dot.
   * @param {number} x
   * @param {number} y
   */
  constructor(x, y) {
    //...
  }
}
```

可扩展对象的动态属性

和 TS 中遇到的问题一样，如果要向对象中动态添加属性，那么类型检查将无法再为后添加的属性提供智能感知。

官方推荐的做法是使用中括号和引号，为可扩展对象设置动态属性。

```javascript
// 向 Element 类添加自定义属性
const btn = document.createElement("button");
btn.nodeValue = "A Button";
// 将会报错： property does not exist on type Node:
btn.isButton = true;
// 不会报错
btn["isButton"] = true;
```

定义对象的类型

定义对象类型有多种方式：对象字面量、带有类型的 Object 关键字等

```javascript
/**
 * @type {Object} obj1
 */

/**
 * 对象字面量方式，在添加动态属性时会报错
 * @type {{}} obj2
 */

/**
 * @type {{name: string, age: number, job: string}} employee
 */

// 定义通用对象类型，允许给对象赋值多种不同类型的属性，且可以给属性定义详细注释，使得 JSDoc 的智能感知更丰富
// @property 这里的属性定义可以不写，区别在于智能感知信息的多与少
/**
 * @type {Object<string, any>} person
 * @property {string} name
 * @property {number} [age]
 * @property {string} [job]
 */
```

泛型（Generic Types）

和 TS 概念相同，JSDoc 使用 @templete 标签定义泛型：

```javascript
/**
 * @template T
 * @param {T} param - 泛型参数将在返回值类型中使用
 * @return {T}
 */
function genericFnc(param) {
  return param;
}
```

引入类型

前面提到通过自定义类型的方式，可以实现在文件中复用这些自定义类型。
下面这个例子定义一个创建 Node 节点的函数。使用 JSDoc 注释定义节点的类型。

```javascript
// 自定义类型定义文件 ./mynode.js
/**
 * Props 在一个 Node 节点上定义属性
 * @typedef {Object.<string, any> | {}} Props
 * @property {Children} Props.children
 */

/**
 * 节点的 children 属性
 * @typedef {VNode[]} Children
 */

/**
 * 为节点定义一个自定义类型 VNode
 * @typedef {string | number | Function} Type
 * @typedef {Object.<string, any>} VNode
 * @property {Type} VNode.type
 * @property {Props} VNode.props
 * @property {Children} VNode.children
 * @property {Key} [VNode.key]
 */
```

那么在使用这个自定义类型的时候，可以这样引入：

```javascript
import { createNodeElement } from '../utils';
/**
 * @typedef {import('./mynode').VNode} VNode
 */

/**
 * @param {Object<string, any>} options
 * @return {VNode} VNode
 */
const vnode = createVNode(options)

// 创建 Node 节点的参数
const options = ..
```

通过这种方式可以在其他文件引入自定义类型。但总感觉这种做法很别扭，类型定义和引入逻辑都隐藏在注释内容中，不是很直观，而且可能很容易写错。

其他标签

JSDoc 注释规范还提供了更加丰富的注释信息，如作者信息、描述信息、函数的作用等等，JSDoc 官方也提供了非常多的标签以实现更加丰富的智能感知。

可以通过查看 react 源码或者一些主流的第三方库源码，了解 JSDoc 更详细的使用场景。
![图一](../images/jsdoc/01.png)
_lodash.js - replace 方法_

[一图释义 JS、TS 与 JsDoc 之间的关系](https://mmbiz.qpic.cn/mmbiz_png/NuViaktGE3RD5yFMibfBSmsoVVNueHH9ele2gOaKz1ROrnjjtaibfI82Cjy0qBw362Nk7jwa31sS7EkyvbzRW20Ww/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)。

TypeDoc

与 JSDoc 是 JS 的文档生成工具相比，TypeDoc 作为 TypeScript 的 API 生成器，在 JSDoc 的基础上简化了一些注释语法，不过有了对 JSDoc 的认识，对于在 TS 中使用 TypeDoc 应该会熟悉的多。
参考 [TYPEDOC GUIDES](https://typedoc.org/guides/doccomments/) 、[TypeDoc Documentation](http://typedoc.org/api/#important-note)。

参考文章

1. [Use JSDoc](https://jsdoc.app/) - Github: [https://github.com/jsdoc/jsdoc](https://github.com/jsdoc/jsdoc)
2. [flow 和 typescript 各有什么好处，该怎么选择？](https://www.zhihu.com/question/49576972) - 知乎
3. [VSCode：基于 JSDoc 的智能感知](https://github.com/Microsoft/TypeScript/wiki/JavaScript-Language-Service-in-Visual-Studio#JsDoc) - Github Wiki
