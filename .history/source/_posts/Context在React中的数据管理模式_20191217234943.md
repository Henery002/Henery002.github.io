---
title: Context在React中的数据管理模式
date: 2019-08-09 17:36:24
tags:
  - 设计模式
  - 状态管理
  - 数据分发
---

## 前言

React 使用单向数据流的设计模式进行数据管理，也就是说父子组件间的数据通信需要依靠 state 或 props 进行传递。如果你的组件层级嵌套较深，那么依然需要一层一层进行 props 的传递（Redux 等状态管理方案暂且不讨论）。

![图1](../../images/context/01.png)
图 1

React 中的 Context 允许状态数据跨层级传递，从而避免部分冗余的代码逻辑，实现数据透传，解决了上述问题所产生的痛点。

![图2](../../images/context/02.png)
图 2

当然，每一种设计模式有其利必有其弊。Context API 实现了组件跨层级的数据通信，同时也带来了一些弊端。所以连官网自己都声明 Context 不是在 React 中实现数据管理的最佳方案。

尽管如此，Context 在 React 生态圈中的应用也还是很广泛的，诸如 react-redux、react-router，甚至于之前项目里用的 react-dnd，也都用到了 Context API 进行全局状态的管理。作为官网中的 ADVANCE API，开发者也有必要去尝试使用它，并了解它能为我们解决什么问题，又会为我们带来什么问题。

## 如何理解 Context

Context 没有什么复杂的概念，但可以把它与 redux 等 react 的状态管理模式相提并论，可以这样理解 Context：

- 函数作用域和作用域链

js 代码在执行过程中会创建对应的上下文作用域，生成对应的作用域链，代码在执行过程中能够通过作用域链访问代码块内部或者外部的变量和方法。这里就可以把 Context 理解成 React 为组件创建的作用域链，Context 对象的属性就可以看做是作用域链上的活动对象，所以组件通过 Context 就可以访问到父组件链上由 Context 提供的属性和方法。

- 状态共享的介质

- 不需要优先考虑使用 Context

React 状态管理的推荐模式还是通过 state 或者 props 进行组件间通信，不需要首选 Context 的模式。因为首先在老版本的 React Context API 中，Context 的作用域是有限的，而且在定义和使用的时候并不是非常直观。

比如旧的 API 中，**父组件提供 Context 首先需要通过 childContextTypes 进行声明，子组件使用父组件的 Context** 属性还需要**使用 contextTypes 进行申请**，从一定程度上来讲，Context 还是没有完全避免 props 层层传递的繁琐性。

好在新版本的 Context API 解决了这个问题，通过新的 API 优化了 Context 数据透传的方式。但同时 Context 使得组件的复用性变差，组件间的耦合性变高，组件的抽象程度受到了限制。这也应该算是 Context 数据管理模式的一个缺点。所以，并不需要优先考虑使用 Context，但完全可以用。

## 适用场景（工作流设计模式）

那么哪些场景下适合使用 Context？

既然 Context 官宣用来跨组件进行数据透传，如果有这样一个需求：在一个 React APP 中很多不同层级的子组件都需要用到某一父组件的部分数据，那么使用 Context 就显得很合适。

说到这里必不可少地要提到 Danastudio v4.0+的工作流模块。工作流模块的代码用来实例讲解 Context 似乎再合适不过。因为它不仅使用新的 Context API 封装 contex，而且包含了**多 Context 嵌套**、**动态创建 Context** 等概念和方式。

这个模块代码逻辑抽象性很高，封装性强的同时也造成组件嵌套过深，部分模块的耦合性也对应变高。

根据项目接手时间来看，工作流模块是上海的老哥哥写于 2018 年上半年，也正是这个时间段（2018/03-2018/04），React v16.3 版本发布，推出了 Context 的新 API。

1. [./Workflow/include/IDEContext.js](http://211.144.114.26:5088/trunk/danastudio/blob/dev/web/src/routes/Workflow/include/IDEContext.js#L49)

![图3](../../images/context/03.png)
图 3

该部分功能用来在工作流画布模块中管理左侧脚本目录树、各个类型脚本之间与上层组件间的部分数据通信。这也就像本节开头说的 Context 所适用的场景。

![图4](../../images/context/04.png)
图 4

这里作了以下三件事：

- 通过 React.createContext **创建多个 Context 对象**；

- 将这些 Context 对象的 Provider 组件挂载到一个 Providers 上一起 export；

- 在 Providers 方法中根据业务逻辑分别返回对应的 **Provider 组件，并赋初值**。

上述逻辑以 Provider 消费者组件为例，Consumer 组件同理。

2. [./Workflow/WorkflowIDE.js](http://211.144.114.26:5088/trunk/danastudio/blob/dev/web/src/routes/Workflow/WorkflowIDE.js#L1241)

![图5](../../images/context/05.png)
图 5

在上层组件 WorkflowIDE 中，调用 Context.Provider 组件并赋初值。这个组件是整个工作流工作区的顶层组件，其内部嵌套很多 Consumer 子组件，诸如：

- ./WorkflowOnlineForm.js
- ./WorkflowCreateForm.js
- ./flow-components/AccDataX.js
- ......

![图6-1](../../images/context/06.png)![图6-2](../../images/context/07.png)
图 6

那么在这些 Consumer 消费者子组件中，通过获取 context 透传的值，去做业务逻辑的处理。比如在创建脚本表单组件中就是这样使用 Consumer 的。

![图7](../../images/context/08.png)
图 7

到这里，相信看过工作流代码的同学对于工作流模块的数据流管理方式已经有了一个大方向上的认识，不至于再为工作流深层嵌套组件间无法找到如何传值的方式而头晕。

综合之前我分享讨论的几个话题：render props、hooks（，甚至于 refs），他们和 Context 似乎都涉及到数据管理。在 Context API 里，Cunsumer 子组件使用 context 的方式就与 render props 很相似，它们都会通过使用一个函数来返回最终的 React 节点，并调用 Provider 父组件的 context 值进行数据渲染。

## Context API

### 旧 Context API 的缺陷

在 Context 早期的版本中定义 Context 组件需要先定义 _childContextTypes_ _、getChildContext_ 才能把 context 传递下去。同时接收组件也要先定义 _contextTypes_ 才能读取到数据，否则即使父组件 Context 中定义了数据，子组件 Context 也会为 _undefined_。

虽然功能上实现了跨层级数据透传，但本质上还是需要一层一层反复声明如何读取 state，没有真正避免层级嵌套带来的效率问题。

那么不可避免地，这种写法会受到状态阻断的影响，当某一个传递组件的 context 发生变化时，如果其中一个中间件的 **shouldComponentUpdate** 方法返回 false，那么其后所有组件都不再接受到 context 的变化从而触发 rerender。

旧的 Context API：

```javascript
/**
 * codesanbox: https://codesandbox.io/s/silly-tu-00dec
 */

import React, { PureComponent } from "react";
import { PropTypes } from "prop-types";

export default class DeliverComponent extends PureComponent {
  getChildContext() {
    return {
      color: "#fff"
    };
  }

  render() {
    return <MidComponent />;
  }
}

DeliverComponent.childContextTypes = {
  color: PropTypes.string
};

const MidComponent = props => <ReceiverComponent />;

const ReceiverComponent = (props, context) => (
  <div style={{ color: context.color }}>接收组件</div>
);
ReceiverComponent.contextTypes = {
  color: PropTypes.string
};
```

## 新 Context API 的应用

- **React.createContext**

创建 Context 对象。用于提供 Provider 和 Consumer 子组件。

- **Context.Provider**

Context 对象提供的生产者组件，相当于父组件。通过赋初值，将 state、props 分发给属于该 Provider 的所有 Consumer。

这里主要与旧版的 Context API 作对比，相当于 getChildContext() 方法。

**注意，Provider 组件并不是必须的**，可以不使用 Context.Provider，Consumer 消费者子组件也能够订阅 Context 的值的变化。只不过此处 Consumer 组件获取到的是 Context 创建时的默认值 defaultValue。

- **Class.contextType**

将 Context 对象挂载到 Class 上，contextType 这个属性会接受上面创建的 Context 对象实例，这样就可以在 Class 中的任何生命周期函数甚至于 render() 方法中通过 this.context 来访问 Provider 的数据。

- Context.Consumer

Context 对象自身提供的 Consumer 组件能够订阅到 context 的变化。
在这个组件中，可以直接通过获取到的 context 的值，来完成后续的业务操作，如通过 children 函数读取 value 去遍历列表，返回一个 React 节点。这一点类似于 render props。

**新 Context API：**

```javascript
/**
 * codesanbox: https://codesandbox.io/s/silly-tu-00dec
 */
import React, { PureComponent } from "react";

const DEFAULT_VALUE = {
  color: "#f83431"
};

// 创建一个唯一 Context
const IDEContext = React.createContext(DEFAULT_VALUE);

const MidComponent = props => <ReceiveComponent />;

// Consumer 子组件通过透传的 context 值进行渲染
const ReceiveComponent = props => (
  <IDEContext.Consumer>
    {context => <div style={{ color: context.color }}>接收 Context</div>}
  </IDEContext.Consumer>
);

export default class DeliverComponent extends PureComponent {
  state = {
    color: "#fff"
  };

  render() {
    return (
      <IDEContext.Provider value={this.state}>
        <MidComponent>
          <ReceiveComponent />
        </MidComponent>
      </IDEContext.Provider>
    );
  }
}
```

**新的 API 在数据传递过程中不会被 shouldComponentUpdate 阻断**，因为它不再需要一层一层声明 Context 上定义的属性值，我们只需要关注 Provider 中的 store 的变化。

## Context 在 React-Router 中的应用

react-router 实现路由管理所使用的几个核心组件 `<Router />`、`<Route />`、`<Link />`、`<Redirect />` 等，就是通过使用 Contex 在这些组件之间共享 router 数据来完成的。

可以翻阅 [react-router](https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules) 源码，进一步了解其设计思想。

1. [RouterContext.js](https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/RouterContext.js)

RouterContext.js 创建并导出了一个名为 context 的 Context，预留给 Router、Route 使用。

![图8](../../images/context/09.png)
图 8

2. [Router.js](https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/Router.js)

`<Route />`作为子组件必须嵌套在`<Router />`中使用，所以 `<Router />` 作为生产者 Provider 组件，核心思想就是为子组件提供一个带有 router 属性的 Context，同时监听 history，一旦 history 发生变化，便通过 setState()触发组件重新渲染。

![图9-1](../../images/context/10.png)![图9-2](../../images/context/11.png)
图 9

3. [Route.js](https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/Route.js)

所以，`<Route / >`组件作为 Consumer Component，通过从 RouterContext 的 Provider 提供的 context 值，返回一个 children function，去渲染路由数据。

![图10-1](../../images/context/12.png)
![图10-2](../../images/context/13.png)
图 10

## Redux 与 Context

redux 的状态管理遵循单一数据流的模式，外部事件通过调用 dispatch 发起 action 到 recuder 中更新 state。react-redux 核心内容包含两个部分：Provider 组件、connect 函数，其中：

1. **Provider** 组件将全局唯一的数据源 **store 注入到 context 中**；

2. **connect** 方法**把 Context 中由 Provider 注入的 store 取出，并通过 props 分发到子组件中**，从而使得子组件能够获取到 redux 中的 store 数据。

react-redux 的源码我没有仔细翻读，但其大致思想和上述 react-router 类似，这里贴上 Provider.js 组件的部分核心代码供参阅：

```javascript
/**
 * react-redux: Provider.js 核心源码
 */
class Provider extends Component {
  constructor(props) {
    super(props);
    const { store } = props; // 全局 store
    this.state = {
      store,
      subscription
    };
    this.previousState = store.getState();
  }
  // ...

  componentDidMount() {
    this.state.subscription.trySubscribe();
    if (this.previousState !== this.props.store.getState()) {
      this.state.subscription.notifyNestedSubs();
    }
  }

  componentWillUnmount() {
    if (this.unsubscribe) this.unsubscribe();
    this.state.subscription.tryUnsubscribe();
  }
  // ...

  render() {
    const Context = this.props.context || ReactReduxContext;
    return (
      <Context.Provider value={this.state}>
        {this.props.children}
      </Context.Provider>
    );
  }
}
// ...
```

## 思考

1. React 中可以通过 Context 进行数据透传，避免了父子级层层传递 props。那么
   使用 Context 如何从子级向父级进行跨组件数据透传？

## 小结

- 相比 props 和 state，React 的 Context 可以实现跨层级的组件通信。

- Context API 的使用基于生产者消费者模式。生产者一方，通过组件静态属性 childContextTypes 声明，然后通过实例方法 getChildContext()创建 Context 对象。消费者一方，通过组件静态属性 contextTypes 申请要用到的 Context 属性，然后通过实例的 context 访问 Context 的属性。

- 合理适当使用 Context。如果可以做到保证 Context 的可控性、耦合性在合理范围内，可以考虑使用。

- ......

其他诸如上述 Context 的优缺点、特性等内容。

## 参考文章：

1. [React 官网](https://reactjs.org/docs/context.html#api) - Context API
2. [避免 React Context 导致的重复渲染](https://zhuanlan.zhihu.com/p/50336226) - 程墨 Morgan [知乎]
3. [从新的 Context API 看 React 应用设计模式](https://zhuanlan.zhihu.com/p/33925435) - 诚身 [知乎]
4. **[Build Yourself a Redux](https://zapier.com/engineering/how-to-build-redux/)** - Justin Deal [zapier]
5. [深入理解 react-router 路由系统](https://zhuanlan.zhihu.com/p/20381597) - 范洪春 [知乎]
6. [你不必使用 Redux：比较 prop 钻取、Redux 和 React Context API](https://juejin.im/post/5cf5d24d6fb9a07eb55f4802) - Ioodu [知乎]
