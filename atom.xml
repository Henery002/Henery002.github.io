<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Henery 的博客</title>
  
  <subtitle>心路历程</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://henery002.github.io/"/>
  <updated>2021-10-22T07:40:00.000Z</updated>
  <id>https://henery002.github.io/</id>
  
  <author>
    <name>魏范光</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React Fiber做了什么</title>
    <link href="https://henery002.github.io/2021/10/22/20.%20React%20Fiber%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://henery002.github.io/2021/10/22/20.%20React%20Fiber%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/</id>
    <published>2021-10-22T02:00:00.000Z</published>
    <updated>2021-10-22T07:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Fiber 是对 React 核心算法的重构。</p><h2 id="从-FPS-入手"><a href="#从-FPS-入手" class="headerlink" title="从 FPS 入手"></a>从 FPS 入手</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Fiber 是对 React 核心算法的重构。&lt;/p&gt;
&lt;h2 id=&quot;从-FPS-入手&quot;&gt;&lt;a href=&quot;#从-FPS-入手&quot; class=&quot;headerlink&quot; title=&quot;从 FPS 入手&quot;&gt;&lt;/a&gt;从 FPS 入手&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="原创" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="技术栈" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="算法" scheme="https://henery002.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="React" scheme="https://henery002.github.io/tags/React/"/>
    
      <category term="diff" scheme="https://henery002.github.io/tags/diff/"/>
    
  </entry>
  
  <entry>
    <title>如何用动态规划解决实际问题</title>
    <link href="https://henery002.github.io/2021/07/23/19.%20%E5%A6%82%E4%BD%95%E7%94%A8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E5%86%B3%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98/"/>
    <id>https://henery002.github.io/2021/07/23/19.%20%E5%A6%82%E4%BD%95%E7%94%A8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E5%86%B3%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98/</id>
    <published>2021-07-23T02:00:00.000Z</published>
    <updated>2021-07-23T07:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;方法论&quot;&gt;&lt;a href=&quot;#方法论&quot; class=&quot;headerlink&quot; title=&quot;方法论&quot;&gt;&lt;/a&gt;方法论&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="原创" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="技术栈" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="算法" scheme="https://henery002.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://henery002.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript如何实现debugger</title>
    <link href="https://henery002.github.io/2021/05/28/18.%20JavaScript%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0debugger/"/>
    <id>https://henery002.github.io/2021/05/28/18.%20JavaScript%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0debugger/</id>
    <published>2021-05-28T02:00:00.000Z</published>
    <updated>2021-05-28T07:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中，调试代码（<code>debugger</code>）是一个必不可少的环节，开发者通常使用 chrome devtools 或者 ide 内置的调试工具等进行单步调试或断点调试。有没有想过 <code>debugger</code> 的运行机制是什么？</p><p><code>debugger</code> 的实现依托于引擎、系统和硬件，计算机操作系统和 CPU 在设计之初就支持了 <code>debugger</code> 的能力，不同语言和平台的 <code>debugger</code> 实现机制不同。想要进一步了解 <code>debugger</code>，首先需要知道代码是如何在计算机（机器）上跑起来的。</p><h2 id="代码运行方式"><a href="#代码运行方式" class="headerlink" title="代码运行方式"></a>代码运行方式</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在开发中，调试代码（&lt;code&gt;debugger&lt;/code&gt;）是一个必不可少的环节，开发者通常使用 chrome devtools 或者 ide 内置的调试工具等进行单步调试或断点调试。有没有想过 &lt;code&gt;debugger&lt;/code&gt; 的运行机制是什么？&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="原创" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="技术栈" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="V8" scheme="https://henery002.github.io/tags/V8/"/>
    
      <category term="原理" scheme="https://henery002.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="debugger" scheme="https://henery002.github.io/tags/debugger/"/>
    
  </entry>
  
  <entry>
    <title>正则捕获组</title>
    <link href="https://henery002.github.io/2021/02/26/17.%20%E6%AD%A3%E5%88%99%E6%8D%95%E8%8E%B7%E7%BB%84/"/>
    <id>https://henery002.github.io/2021/02/26/17.%20%E6%AD%A3%E5%88%99%E6%8D%95%E8%8E%B7%E7%BB%84/</id>
    <published>2021-02-26T02:00:00.000Z</published>
    <updated>2021-02-26T07:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>有这样一个题目：<br>对于以下字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"  primary key( pk1 , pk2 ) ,  pk1 int , pk2 int "</span>;</span></pre></td></tr></table></figure><h2 id="捕获组（Grouping）"><a href="#捕获组（Grouping）" class="headerlink" title="捕获组（Grouping）"></a>捕获组（Grouping）</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有这样一个题目：&lt;br&gt;对于以下字符串&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td
      
    
    </summary>
    
    
      <category term="原创" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="技术栈" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="正则表达式" scheme="https://henery002.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>如何理解ECMAScript规范</title>
    <link href="https://henery002.github.io/2020/11/13/16.%20%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3ECMAScript%E8%A7%84%E8%8C%83/"/>
    <id>https://henery002.github.io/2020/11/13/16.%20%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3ECMAScript%E8%A7%84%E8%8C%83/</id>
    <published>2020-11-13T02:00:00.000Z</published>
    <updated>2020-11-13T07:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要读-ES-规范"><a href="#为什么要读-ES-规范" class="headerlink" title="为什么要读 ES 规范"></a>为什么要读 ES 规范</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要读-ES-规范&quot;&gt;&lt;a href=&quot;#为什么要读-ES-规范&quot; class=&quot;headerlink&quot; title=&quot;为什么要读 ES 规范&quot;&gt;&lt;/a&gt;为什么要读 ES 规范&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="原创" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="技术栈" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="源码" scheme="https://henery002.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="ES" scheme="https://henery002.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>V8中的js同值相等</title>
    <link href="https://henery002.github.io/2020/08/14/15.%20V8%E4%B8%AD%E7%9A%84js%E5%90%8C%E5%80%BC%E7%9B%B8%E7%AD%89/"/>
    <id>https://henery002.github.io/2020/08/14/15.%20V8%E4%B8%AD%E7%9A%84js%E5%90%8C%E5%80%BC%E7%9B%B8%E7%AD%89/</id>
    <published>2020-08-14T02:00:00.000Z</published>
    <updated>2020-08-14T07:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="原创" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="技术栈" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="源码" scheme="https://henery002.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="V8" scheme="https://henery002.github.io/tags/V8/"/>
    
      <category term="函数式编程" scheme="https://henery002.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Monoid" scheme="https://henery002.github.io/tags/Monoid/"/>
    
  </entry>
  
  <entry>
    <title>代码兼容性问题检查方案</title>
    <link href="https://henery002.github.io/2020/07/27/14.%20%E4%BB%A3%E7%A0%81%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E6%A3%80%E6%9F%A5%E6%96%B9%E6%A1%88/"/>
    <id>https://henery002.github.io/2020/07/27/14.%20%E4%BB%A3%E7%A0%81%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E6%A3%80%E6%9F%A5%E6%96%B9%E6%A1%88/</id>
    <published>2020-07-27T02:00:00.000Z</published>
    <updated>2020-07-27T07:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="原创" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="技术栈" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="兼容性" scheme="https://henery002.github.io/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
      <category term="eslint" scheme="https://henery002.github.io/tags/eslint/"/>
    
  </entry>
  
  <entry>
    <title>V8底层如何实现JSArray</title>
    <link href="https://henery002.github.io/2020/05/28/13.%20V8%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0JSArray/"/>
    <id>https://henery002.github.io/2020/05/28/13.%20V8%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0JSArray/</id>
    <published>2020-05-28T02:00:00.000Z</published>
    <updated>2020-05-28T07:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="原创" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="技术栈" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="源码" scheme="https://henery002.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="V8" scheme="https://henery002.github.io/tags/V8/"/>
    
  </entry>
  
  <entry>
    <title>antd-Table@4.x对rowKey属性的重构</title>
    <link href="https://henery002.github.io/2020/04/26/12.%20antd-Table@4.x%E5%AF%B9rowKey%E5%B1%9E%E6%80%A7%E7%9A%84%E9%87%8D%E6%9E%84/"/>
    <id>https://henery002.github.io/2020/04/26/12.%20antd-Table@4.x%E5%AF%B9rowKey%E5%B1%9E%E6%80%A7%E7%9A%84%E9%87%8D%E6%9E%84/</id>
    <published>2020-04-26T02:00:00.000Z</published>
    <updated>2020-04-26T07:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="原创" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="技术栈" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="antd" scheme="https://henery002.github.io/tags/antd/"/>
    
      <category term="源码" scheme="https://henery002.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="重构" scheme="https://henery002.github.io/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>浏览器市场占有率分析</title>
    <link href="https://henery002.github.io/2020/03/11/11.%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B8%82%E5%9C%BA%E5%8D%A0%E6%9C%89%E7%8E%87%E5%88%86%E6%9E%90/"/>
    <id>https://henery002.github.io/2020/03/11/11.%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B8%82%E5%9C%BA%E5%8D%A0%E6%9C%89%E7%8E%87%E5%88%86%E6%9E%90/</id>
    <published>2020-03-11T02:00:00.000Z</published>
    <updated>2020-03-11T07:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为解决浏览器兼容问题，本文主要调研当前市场上的主流浏览器及其市场份额，为确定兼容目标提供部分参考依据。</p></blockquote><h2 id="浏览器及其内核"><a href="#浏览器及其内核" class="headerlink" title="浏览器及其内核"></a>浏览器及其内核</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;为解决浏览器兼容问题，本文主要调研当前市场上的主流浏览器及其市场份额，为确定兼容目标提供部分参考依据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;浏览器及其内核&quot;&gt;&lt;a href=&quot;#浏览器及其内核&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="原创" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="技术栈" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="浏览器" scheme="https://henery002.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="兼容性" scheme="https://henery002.github.io/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Git/Linux常用CLI</title>
    <link href="https://henery002.github.io/2020/02/28/10-gitlinux%E5%B8%B8%E7%94%A8cli/"/>
    <id>https://henery002.github.io/2020/02/28/10-gitlinux%E5%B8%B8%E7%94%A8cli/</id>
    <published>2020-02-28T02:00:00.000Z</published>
    <updated>2020-02-28T07:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇内容主要是根据实际项目中的经验积累与总结，归纳在当前的前端工作场景中高频使用的 git cli 及 linux cli，便于加深记忆与熟练使用。</p><h2 id="一、Git"><a href="#一、Git" class="headerlink" title="一、Git"></a>一、Git</h2><p>梳理 git 操作中容易混淆和被忽视的几个概念：</p><p><strong>1. untracked flies</strong></p><p>git 系统中的文件具有生命周期，新添加到 git 仓库中的本地文件会被系统默认为未被追踪的文件。<br><img src="../images/10-CLI/image.png" alt="图片"></p><p>删除无用的 <code>untracked files</code> 文件：</p><ul><li>git clean [-xndf]</li></ul><p><strong>2. git stash</strong></p><ul><li>git stash list</li><li>git stash pop [stash@{idx}]</li><li>git stash drop [stash@{idx}]</li><li>git stash clear</li></ul><p><strong>3. git reset</strong></p><ul><li>工作区、暂存区、版本库的关联性</li></ul><p><img src="/.io//image-1.png" alt="图片"></p><ul><li><p><strong>reset [–soft|–hard|–mixed]</strong><br><img src="../images/10-CLI/image-2.png" alt="图片"></p><ul><li><p><strong>git reset –soft HEAD^</strong><br>回滚到上一个提交，同时保留暂存区和工作目录的内容。</p></li><li><p><strong>git reset [–mixed] HEAD^</strong><br>回滚到上一个提交，同时清空暂存区并保留工作目录的内容。</p></li><li><p><strong>git reset –hard HEAD^</strong><br>回滚到上一个提交，同时清空暂存区和工作目录的所有改动。</p><p>【由此可推：当使用 <code>git cherry-pick</code> 后改动处于版本库（即 commit 之后）中，此时想要撤回 <code>cherry-pick</code> 即执行 <code>git reset HEAD^</code> 即可。】</p></li></ul></li></ul><p>例：</p><p>当前 working directory 区状态（状态 1）：<br><img src="../images/10-CLI/image-3.png" alt="图片"></p><p>当前 stage 区状态（状态 2）：<br><img src="../images/10-CLI/image-4.png" alt="图片"></p><p>commit 后，head 区状态（状态 3）：<br><img src="../images/10-CLI/image-5.png" alt="图片"></p><p>此时 HEAD^ 为当前 commit：<br><img src="../images/10-CLI/image-6.png" alt="图片"></p><p>那么，–soft 模式将由状态 3 回到状态 2：<br><img src="../images/10-CLI/image-7.png" alt="图片"></p><p>–mixed 模式将由状态 3 回到状态 1，对应的 HEAD 也将由 HEAD^变为 HEAD^^。<br><img src="../images/10-CLI/image-8.png" alt="图片"></p><p>如果在执行一次 <code>git reset --soft HEAD^</code> 之后在执行一次 <code>git reset --soft HEAD^</code>，则将回滚到 <code>HEAD^^</code> 的提交状态，此时工作目录中的代码改动可能已经不是你自己所做的改动了。</p><p>这种情况下通过 <code>git reset --hard HEAD^</code> 可以撤销当前工作目录和暂存区的改动，恢复异常状态，重新 pull。</p><h2 id="二、Linux"><a href="#二、Linux" class="headerlink" title="二、Linux"></a>二、Linux</h2><p>以 linux 系统作为前端开发环境也是可选的工具技术栈。在 linux 开发环境下项目代码将部署在远程服务器上，开发人员可以直接读写远程服务器上的项目代码，执行同步、修改、部署（打包）等系列操作。<strong>面向前端的</strong> linux 常用 cli 并不多，根据开发过程中遇到的实际场景，整理归纳了部分命令行的使用注意点。</p><h4 id="1-远程登录"><a href="#1-远程登录" class="headerlink" title="1. 远程登录"></a>1. 远程登录</h4><ul><li><strong>ssh</strong><br>linux 系统下通过 ssh 服务实现对远程服务器的连接。ssh 服务会把系统访问过的每一台计算机的公钥（public_key）记录下来（~/.ssh/known_hosts），以便再次访问该主机时进行核验，如 publick_key 不同，ssh 服务会发出警告（出于安全性考虑）。</li></ul><p><img src="../images/10-CLI/image-9.png" alt="图片"></p><h4 id="2-文件-磁盘管理"><a href="#2-文件-磁盘管理" class="headerlink" title="2. 文件/磁盘管理"></a>2. 文件/磁盘管理</h4><h5 id="a-基本操作"><a href="#a-基本操作" class="headerlink" title="a. 基本操作"></a>a. 基本操作</h5><ul><li>mkdir</li><li>touch</li><li>rm -rf /*</li></ul><h5 id="b-压缩备份"><a href="#b-压缩备份" class="headerlink" title="b. 压缩备份"></a>b. 压缩备份</h5><ul><li><p>tar [-cxzvf]<br>-c # 建立压缩文件<br>-x # 还原文件<br>-z # 通过 gzip 指令处理压缩文件<br>-v # 显示解压缩执行过程<br>-f # 指定备份文件</p><p>常用于对打包文件进行解压还原，或将日志文件进行打包输出。<br><img src="../images/10-CLI/image-10.png" alt="图片"><br><img src="../images/10-CLI/image-11.png" alt="图片"></p></li></ul><h5 id="c-文件查找"><a href="#c-文件查找" class="headerlink" title="c. 文件查找"></a>c. 文件查找</h5><ul><li><p>find</p><ol><li>服务器端经常遇到磁盘被占满的情况，通常情况下由大的日志文件造成。<br>查找大文件并删除：<br><img src="../images/10-CLI/image-12.png" alt="图片"></li><li>模糊查询：<br><img src="../images/10-CLI/image-13.png" alt="图片"></li></ol></li><li><p>grep [-r]<br>查找文件中符合条件的字符串。<br>如查找打包文件源代码中是否包含关键字（以排查代码提交是否正常）：</p></li><li><p>whereis [-bm]<br>查找二进制文件（应用程序）。<br>如查找 yum 指令安装位置（及软连接、man 帮助手册）：<br><img src="../images/10-CLI/image-14.png" alt="图片"></p></li><li><p>locate # 查找文档（在/lib 数据库中查找）</p></li></ul><h5 id="d-文件权限"><a href="#d-文件权限" class="headerlink" title="d. 文件权限"></a>d. 文件权限</h5><ul><li><p>chmod [options] mode files<br>文件的 9 种属性：<br>[ d | r w x | r - x | r - x ]<br>[ 文件类型 | 读 写 执行 | 读 写 执行 | 读 写 执行 ]<br>[ | 4 2 1 | 4 2 1 | 4 2 1 ]<br>[ | u(用户) | g(组) | o(其他) ]<br><img src="../images/10-CLI/image-15.png" alt="图片"></p><p><strong>参数：</strong><br>mode: [ugoa][=+-][rwxX]，其中 r/w/x 权限分别通过数值 4/2/1 表示，因此权限又可以通过数值运算的值来表示。</p><p>所以，可使用参数操作符修改文件权限。</p><ol><li>chmod 777 filename # =&gt; [drwxrwxrwx]</li><li>chmod 445 filename # =&gt; [dr–r–r-x]</li><li>chmod u=rw,g-w,o+wx # =&gt; [drw-r–rwx]</li><li>chmod a-x filename # =&gt; [drw-rw-rw-]</li></ol></li></ul><h5 id="e-文件拷贝"><a href="#e-文件拷贝" class="headerlink" title="e. 文件拷贝"></a>e. 文件拷贝</h5><ul><li><p>scp [-r]<br>linux 系统下跨服务器文件拷贝，参数-r 可递归遍历文件夹里面的内容。</p><ol><li><p>从远程服务器拷贝文件夹（文件）到本地主机<br><img src="../images/10-CLI/image-16.png" alt="图片"></p></li><li><p>将本地主机文件夹（文件）拷贝到远程服务器<br><img src="../images/10-CLI/image-17.png" alt="图片"></p></li></ol></li><li><p>rcp [-r]</p></li></ul><h5 id="f-组合指令"><a href="#f-组合指令" class="headerlink" title="f. 组合指令"></a>f. 组合指令</h5><ul><li>ls -a;pwd</li><li>mkdir tempfile &amp;&amp; cd tempfile</li></ul><h5 id="g-定向输出"><a href="#g-定向输出" class="headerlink" title="g. 定向输出"></a>g. 定向输出</h5><ul><li>find . -name <em>xplo</em>.js &gt; mylog</li></ul><h4 id="3-网络系统"><a href="#3-网络系统" class="headerlink" title="3. 网络系统"></a>3. 网络系统</h4><ul><li><p><strong>ping [-c] &lt;address&gt;</strong> # 测试本机与目标主机的连通性、稳定性<br><img src="../images/10-CLI/image-18.png" alt="图片"></p><p><strong>其中：</strong><br>1: ping 目标主机域名(IP)<br>2: 包文件大小<br>3: ping 序列（参数-c 指定）<br>4: 包文件收发数、丢包率<br>5: 最小/平均/最大响应时间</p><p>丢包率偏高连接不稳定的情况：</p></li><li><p><strong>ifconfig</strong> # 网络配置<br>可通过参数配置，或编辑网络配置文件 /etc/sysconfig/network-script/ifcfg-ens0 修改。<br><img src="../images/10-CLI/image-19.png" alt="图片"></p><p>网络配置修改后，需要执行 service network restart 重启生效。</p></li><li><p><strong>systemctl status &lt;servicename&gt;</strong> # 查看服务运行状态<br>以 192.168.80.233 节点 danastudio 服务为例：<br><img src="../images/10-CLI/image-20.png" alt="图片"></p></li><li><p><strong>systemctl restart network</strong> # 重启服务</p></li></ul><h4 id="4-创建别名"><a href="#4-创建别名" class="headerlink" title="4. 创建别名"></a>4. 创建别名</h4><ul><li><strong>alias</strong><br>使用 alias <shortname>=<command name> 定义一次性别名，仅供当前会话窗口使用。<br>linux 下编辑 ~/.bashrc （macOS 下 ~/.bash_profile）保存别名设置，永久生效。<br><img src="../images/10-CLI/image-21.png" alt="图片"></shortname></li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg4MTYwMzY1Mw==&mid=2247496319&idx=1&sn=a9d8e79a0e679dedf80eccd53eacbc52&source=41#wechat_redirect" target="_blank" rel="noopener">让你牛 B 加身的前端必会 Linux 命令</a> - 奇舞周刊</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇内容主要是根据实际项目中的经验积累与总结，归纳在当前的前端工作场景中高频使用的 git cli 及 linux cli，便于加深记忆与熟练使用。&lt;/p&gt;
&lt;h2 id=&quot;一、Git&quot;&gt;&lt;a href=&quot;#一、Git&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
      <category term="原创" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="技术栈" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="CLI" scheme="https://henery002.github.io/tags/CLI/"/>
    
      <category term="git" scheme="https://henery002.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的类型检查[JSDoc版]</title>
    <link href="https://henery002.github.io/2019/11/15/9.%20%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5[JSDoc%E7%89%88]/"/>
    <id>https://henery002.github.io/2019/11/15/9.%20%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5[JSDoc%E7%89%88]/</id>
    <published>2019-11-15T02:00:00.000Z</published>
    <updated>2019-12-18T03:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS-的特性"><a href="#JS-的特性" class="headerlink" title="JS 的特性"></a>JS 的特性</h2><p>对于前端开发者来说，JsvaScript 是一门弱类型语言，它的类型系统没有强类型语言（Java 等）提供的类型系统复杂和完善，这也就导致了一个必然的问题：需要一些额外的方案为其做类型声明。而为 Javascript 作类型声明也将会是一件比较麻烦的事。</p><p>在既有的技术栈范围内以及实战项目中，我们已经接触到了使用 PropTypes、TypeScript 这些静态类型检查器为 js 在进入运行阶段之前作类型检查的方式。</p><h2 id="类型检查解决方案"><a href="#类型检查解决方案" class="headerlink" title="类型检查解决方案"></a>类型检查解决方案</h2><ul><li><p>Flow：<a href="https://flow.org/en/docs/react/components/" target="_blank" rel="noopener">官方文档</a></p><ul><li>静态类型检查器，通过一套特属语法为变量、函数、组件提供注解。</li></ul></li><li><p>TypeScript：<a href="https://ts.xcatliu.com/" target="_blank" rel="noopener">TypeScript 入门教程</a></p><ul><li>JS 的类型超集，作为一种独立的类型语言存在，类型系统复杂强大。</li></ul></li><li><p><a href="https://react.docschina.org/docs/static-type-checking.html" target="_blank" rel="noopener">PropTypes</a></p><ul><li>通过配置 propTypes 属性为组件 props 设置类型检查。</li></ul></li><li><p>JSDoc：<a href="https://jsdoc.app/tags-class.html" target="_blank" rel="noopener">技术手册</a></p><ul><li>一个根据 JS 文件的注释信息生成 JS 应用程序或库、模块的 API 文档工具。</li><li>JSDoc 注释是标准的 JS 注释，使用方便，不需要向 TS 一样需要构建步骤来转换语法，是为 JS 提供类型检查成本最低的方式。</li></ul></li></ul><p>本文关注用 JSDoc 注释实现类型检查。</p><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><ol><li><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">npm install -g jsdoc</span></pre></td></tr></table></figure><ol start="2"><li><h3 id="配置生成规则"><a href="#配置生成规则" class="headerlink" title="配置生成规则"></a>配置生成规则</h3></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// jsdoc.json</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"source"</span>: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"include"</span>: [<span class="string">"src/"</span>] <span class="comment">// 需要生成文档的对应 js 路径</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"opts"</span>: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"destination"</span>: <span class="string">"docs/"</span>, <span class="comment">// 文档生成目录</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"readme"</span>: <span class="string">"docs/index.md"</span>, <span class="comment">// 文档首页展示内容</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"template"</span>: <span class="string">""</span>, <span class="comment">// 文档模板，可自行寻找合适的 API 生成模板替换使用</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"encoding"</span>: <span class="string">"utf8"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"templates"</span>: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 模板配置，此处跟模板设置有关</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"plugins/markdown"</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"markdown"</span>: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"tags"</span>: [<span class="string">"example"</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"idInHeadings"</span>: <span class="literal">true</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>比如一套模板配置项可以为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"templates"</span>: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"default"</span>: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 可自定义指定添加到 styles 的目录</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      <span class="attr">"staticFiles"</span>: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"include"</span>: [<span class="string">"./static"</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"css"</span>: [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">      <span class="string">"styles/style.css"</span> <span class="comment">// 自定义样式</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    ],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"name"</span>: <span class="string">"Doc Template"</span>, <span class="comment">// 文档名称</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"tabNames"</span>: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 导航名称</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">      <span class="attr">"tutorials"</span>: <span class="string">"wiki"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">      <span class="attr">"apiName"</span>: <span class="string">"api"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><ol start="3"><li><h3 id="生成-API-文档"><a href="#生成-API-文档" class="headerlink" title="生成 API 文档"></a>生成 API 文档</h3></li><li><h3 id="VSCode-插件"><a href="#VSCode-插件" class="headerlink" title="VSCode 插件"></a>VSCode 插件</h3></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// settings.json</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">"javascript.implicitProjectConfig.checkJs": true, //开启类型检查 "</span></pre></td></tr></table></figure><h2 id="JsDoc-注释"><a href="#JsDoc-注释" class="headerlink" title="JsDoc 注释"></a>JsDoc 注释</h2><h3 id="打开-关闭类型检查"><a href="#打开-关闭类型检查" class="headerlink" title="打开/关闭类型检查"></a>打开/关闭类型检查</h3><ul><li>@ts-check</li><li>@ts-nocheck</li><li>@ts-ignore</li></ul><h3 id="使用-JSDoc-定义类型"><a href="#使用-JSDoc-定义类型" class="headerlink" title="使用 JSDoc 定义类型"></a>使用 JSDoc 定义类型</h3><ol><li><h4 id="type-声明一个类型"><a href="#type-声明一个类型" class="headerlink" title="@type 声明一个类型"></a>@type 声明一个类型</h4></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @type &#123;string&#125; address - 地址</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> address = <span class="string">"NJ"</span>;</span></pre></td></tr></table></figure><p>声明类型的方式和 TypeScript 是一样的，都具有 string、number、undefined、Array、Object 等类型，包括 string[]、Object[]、any[]。同时也可以使用联合类型和交集类型。<br>在定义类型的时候尽量避免定义 any 类型，最好使用联合类型或者交集类型来代替。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @type &#123;number | string&#125; page</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> page = <span class="number">12</span>; <span class="comment">// or '12'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @type &#123;&#123;name: string&#125;, &#123;age: number&#125;&#125; person</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  name: <span class="string">"TACK"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  age: <span class="number">22</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure><ol start="2"><li><h4 id="typedef-定义自定义类型，可以为其定义属性"><a href="#typedef-定义自定义类型，可以为其定义属性" class="headerlink" title="@typedef 定义自定义类型，可以为其定义属性"></a>@typedef 定义自定义类型，可以为其定义属性</h4></li></ol><p>自定义类型在类型被反复使用时很有必要，类似于 TS 中的 interface、type。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 包含姓名和年龄的对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @typedef &#123;Object&lt;string, any&gt;&#125; Person</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @property &#123;string&#125; name - 姓名</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @property &#123;number&#125; [age] - 年龄</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @type &#123;Person&#125; person</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  name: <span class="string">"JACK"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  age: <span class="number">22</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure><ol start="3"><li><h4 id="function-或-class-定义函数或类方法"><a href="#function-或-class-定义函数或类方法" class="headerlink" title="@function 或 @class 定义函数或类方法"></a>@function 或 @class 定义函数或类方法</h4></li></ol><p>定义时需要使用 @param 定义函数参数，使用 @return 定义函数返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 预览版，编辑（即失焦）、删除自动匹配映射的代码表的值，删除时需要删除掉新增的这一整行</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @param &#123;&#123;id: number&#125;&#125; record - 该行属性集合</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @param &#123;number&#125; [idx] - 当前行当前输入框的下标，值为 0/1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @param &#123;&#123;&#125;&#125; [fieldsValue] - 表单值集合，用于编辑，不传该值表示删除</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @return void</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">getInputAITableChange = <span class="function">(<span class="params">record, idx, fieldsValue</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure><ol start="4"><li><h4 id="扩展类（Extending-Classes）"><a href="#扩展类（Extending-Classes）" class="headerlink" title="扩展类（Extending Classes）"></a>扩展类（Extending Classes）</h4></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Class</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @extends Point</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dot</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">   * Create a dot.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">   * @param &#123;number&#125; x</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">   * @param &#123;number&#125; y</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment">   */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><ol start="5"><li><h4 id="可扩展对象的动态属性"><a href="#可扩展对象的动态属性" class="headerlink" title="可扩展对象的动态属性"></a>可扩展对象的动态属性</h4></li></ol><p>和 TS 中遇到的问题一样，如果要向对象中动态添加属性，那么类型检查将无法再为后添加的属性提供智能感知。</p><p>官方推荐的做法是使用中括号和引号，为可扩展对象设置动态属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向 Element 类添加自定义属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.createElement(<span class="string">"button"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">btn.nodeValue = <span class="string">"A Button"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将会报错： property does not exist on type Node:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">btn.isButton = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不会报错</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">btn[<span class="string">"isButton"</span>] = <span class="literal">true</span>;</span></pre></td></tr></table></figure><ol start="6"><li><h4 id="定义对象的类型"><a href="#定义对象的类型" class="headerlink" title="定义对象的类型"></a>定义对象的类型</h4></li></ol><p>定义对象类型有多种方式：对象字面量、带有类型的 Object 关键字等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @type &#123;Object&#125; obj1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 对象字面量方式，在添加动态属性时会报错</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @type &#123;&#123;&#125;&#125; obj2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @type &#123;&#123;name: string, age: number, job: string&#125;&#125; employee</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义通用对象类型，允许给对象赋值多种不同类型的属性，且可以给属性定义详细注释，使得 JSDoc 的智能感知更丰富</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// @property 这里的属性定义可以不写，区别在于智能感知信息的多与少</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @type &#123;Object&lt;string, any&gt;&#125; person</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @property &#123;string&#125; name</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @property &#123;number&#125; [age]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @property &#123;string&#125; [job]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr></table></figure><ol start="7"><li><h4 id="泛型（Generic-Types）"><a href="#泛型（Generic-Types）" class="headerlink" title="泛型（Generic Types）"></a>泛型（Generic Types）</h4></li></ol><p>和 TS 概念相同，JSDoc 使用 @templete 标签定义泛型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @template T</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @param &#123;T&#125; param - 泛型参数将在返回值类型中使用</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @return &#123;T&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genericFnc</span>(<span class="params">param</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> param;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><ol start="8"><li><h4 id="引入类型"><a href="#引入类型" class="headerlink" title="引入类型"></a>引入类型</h4></li></ol><p>前面提到通过自定义类型的方式，可以实现在文件中复用这些自定义类型。</p><p>下面这个例子定义一个创建 Node 节点的函数。使用 JSDoc 注释定义节点的类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义类型定义文件 ./mynode.js</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Props 在一个 Node 节点上定义属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @typedef &#123;Object.&lt;string, any&gt; | &#123;&#125;&#125; Props</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @property &#123;Children&#125; Props.children</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 节点的 children 属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @typedef &#123;VNode[]&#125; Children</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 为节点定义一个自定义类型 VNode</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @typedef &#123;string | number | Function&#125; Type</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @typedef &#123;Object.&lt;string, any&gt;&#125; VNode</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @property &#123;Type&#125; VNode.type</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @property &#123;Props&#125; VNode.props</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @property &#123;Children&#125; VNode.children</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @property &#123;Key&#125; [VNode.key]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr></table></figure><p>那么在使用这个自定义类型的时候，可以这样引入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createNodeElement &#125; <span class="keyword">from</span> <span class="string">'../utils'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @typedef &#123;import('./mynode').VNode&#125; VNode</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @param &#123;Object&lt;string, any&gt;&#125; options</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * @return &#123;VNode&#125; VNode</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vnode = createVNode(options)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Node 节点的参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = ..</span></pre></td></tr></table></figure><p>通过这种方式可以在其他文件引入自定义类型。但总感觉这种做法很别扭，类型定义和引入逻辑都隐藏在注释内容中，不是很直观，而且可能很容易写错。</p><ol start="9"><li><h4 id="其他标签"><a href="#其他标签" class="headerlink" title="其他标签"></a>其他标签</h4></li></ol><p>JSDoc 注释规范还提供了更加丰富的注释信息，如作者信息、描述信息、函数的作用等等，JSDoc 官方也提供了非常多的标签以实现更加丰富的智能感知。</p><p>可以通过查看 react 源码或者一些主流的第三方库源码，了解 JSDoc 更详细的使用场景。<br><img src="../images/jsdoc/01.png" alt="图一"> <em>lodash.js - replace 方法</em></p><p><a href="https://mmbiz.qpic.cn/mmbiz_png/NuViaktGE3RD5yFMibfBSmsoVVNueHH9ele2gOaKz1ROrnjjtaibfI82Cjy0qBw362Nk7jwa31sS7EkyvbzRW20Ww/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" target="_blank" rel="noopener">一图释义 JS、TS 与 JsDoc 之间的关系</a>。</p><h2 id="TypeDoc"><a href="#TypeDoc" class="headerlink" title="TypeDoc"></a>TypeDoc</h2><p>与 JSDoc 是 JS 的文档生成工具相比，TypeDoc 作为 TypeScript 的 API 生成器，在 JSDoc 的基础上简化了一些注释语法，不过有了对 JSDoc 的认识，对于在 TS 中使用 TypeDoc 应该会熟悉的多。</p><p>参考 <a href="https://typedoc.org/guides/doccomments/" target="_blank" rel="noopener">TYPEDOC GUIDES</a> 、<a href="http://typedoc.org/api/#important-note" target="_blank" rel="noopener">TypeDoc Documentation</a>。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://jsdoc.app/" target="_blank" rel="noopener">Use JSDoc</a> - Github: <a href="https://github.com/jsdoc/jsdoc" target="_blank" rel="noopener">https://github.com/jsdoc/jsdoc</a></li><li><a href="https://www.zhihu.com/question/49576972" target="_blank" rel="noopener">flow 和 typescript 各有什么好处，该怎么选择？</a> - 知乎</li><li><a href="https://github.com/Microsoft/TypeScript/wiki/JavaScript-Language-Service-in-Visual-Studio#JsDoc" target="_blank" rel="noopener">VSCode：基于 JSDoc 的智能感知</a> - Github Wiki</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JS-的特性&quot;&gt;&lt;a href=&quot;#JS-的特性&quot; class=&quot;headerlink&quot; title=&quot;JS 的特性&quot;&gt;&lt;/a&gt;JS 的特性&lt;/h2&gt;&lt;p&gt;对于前端开发者来说，JsvaScript 是一门弱类型语言，它的类型系统没有强类型语言（Java 等）提供的
      
    
    </summary>
    
    
      <category term="原创" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="技术栈" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="类型检查" scheme="https://henery002.github.io/tags/%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5/"/>
    
      <category term="JSDoc" scheme="https://henery002.github.io/tags/JSDoc/"/>
    
  </entry>
  
  <entry>
    <title>Context在React中的数据管理模式</title>
    <link href="https://henery002.github.io/2019/08/09/8.%20Context%E5%9C%A8React%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://henery002.github.io/2019/08/09/8.%20Context%E5%9C%A8React%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2019-08-09T09:36:24.000Z</published>
    <updated>2020-02-21T07:15:14.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>React 使用单向数据流的设计模式进行数据管理，也就是说父子组件间的数据通信需要依靠 state 或 props 进行传递。如果你的组件层级嵌套较深，那么依然需要一层一层进行 props 的传递（Redux 等状态管理方案暂且不讨论）。</p><p><img src="../images/context/01.png" alt="图1"></p><p>React 中的 Context 允许状态数据跨层级传递，从而避免部分冗余的代码逻辑，实现数据透传，解决了上述问题所产生的痛点。</p><p><img src="../images/context/02.png" alt="图2"></p><p>当然，每一种设计模式有其利必有其弊。Context API 实现了组件跨层级的数据通信，同时也带来了一些弊端。所以连官网自己都声明 Context 不是在 React 中实现数据管理的最佳方案。</p><p>尽管如此，Context 在 React 生态圈中的应用也还是很广泛的，诸如 react-redux、react-router，甚至于之前项目里用的 react-dnd，也都用到了 Context API 进行全局状态的管理。作为官网中的 ADVANCE API，开发者也有必要去尝试使用它，并了解它能为我们解决什么问题，又会为我们带来什么问题。</p><h2 id="如何理解-Context"><a href="#如何理解-Context" class="headerlink" title="如何理解 Context"></a>如何理解 Context</h2><p>Context 没有什么复杂的概念，但可以把它与 redux 等 react 的状态管理模式相提并论，可以这样理解 Context：</p><ul><li>函数作用域和作用域链</li></ul><p>js 代码在执行过程中会创建对应的上下文作用域，生成对应的作用域链，代码在执行过程中能够通过作用域链访问代码块内部或者外部的变量和方法。这里就可以把 Context 理解成 React 为组件创建的作用域链，Context 对象的属性就可以看做是作用域链上的活动对象，所以组件通过 Context 就可以访问到父组件链上由 Context 提供的属性和方法。</p><ul><li><p>状态共享的介质</p></li><li><p>不需要优先考虑使用 Context</p></li></ul><p>React 状态管理的推荐模式还是通过 state 或者 props 进行组件间通信，不需要首选 Context 的模式。因为首先在老版本的 React Context API 中，Context 的作用域是有限的，而且在定义和使用的时候并不是非常直观。</p><p>比如旧的 API 中，<strong>父组件提供 Context 首先需要通过 childContextTypes 进行声明，子组件使用父组件的 Context</strong> 属性还需要<strong>使用 contextTypes 进行申请</strong>，从一定程度上来讲，Context 还是没有完全避免 props 层层传递的繁琐性。</p><p>好在新版本的 Context API 解决了这个问题，通过新的 API 优化了 Context 数据透传的方式。但同时 Context 使得组件的复用性变差，组件间的耦合性变高，组件的抽象程度受到了限制。这也应该算是 Context 数据管理模式的一个缺点。所以，并不需要优先考虑使用 Context，但完全可以用。</p><h2 id="适用场景（工作流设计模式）"><a href="#适用场景（工作流设计模式）" class="headerlink" title="适用场景（工作流设计模式）"></a>适用场景（工作流设计模式）</h2><p>那么哪些场景下适合使用 Context？</p><p>既然 Context 官宣用来跨组件进行数据透传，如果有这样一个需求：在一个 React APP 中很多不同层级的子组件都需要用到某一父组件的部分数据，那么使用 Context 就显得很合适。</p><p>说到这里必不可少地要提到 Danastudio v4.0+的工作流模块。工作流模块的代码用来实例讲解 Context 似乎再合适不过。因为它不仅使用新的 Context API 封装 contex，而且包含了<strong>多 Context 嵌套</strong>、<strong>动态创建 Context</strong> 等概念和方式。</p><p>这个模块代码逻辑抽象性很高，封装性强的同时也造成组件嵌套过深，部分模块的耦合性也对应变高。</p><p>根据项目接手时间来看，工作流模块是上海的老哥哥写于 2018 年上半年，也正是这个时间段（2018/03-2018/04），React v16.3 版本发布，推出了 Context 的新 API。</p><ol><li><a href="http://211.144.114.26:5088/trunk/danastudio/blob/dev/web/src/routes/Workflow/include/IDEContext.js#L49" target="_blank" rel="noopener">./Workflow/include/IDEContext.js</a></li></ol><p><img src="../images/context/03.png" alt="图3"></p><p>该部分功能用来在工作流画布模块中管理左侧脚本目录树、各个类型脚本之间与上层组件间的部分数据通信。这也就像本节开头说的 Context 所适用的场景。</p><p><img src="../images/context/04.png" alt="图4"></p><p>这里作了以下三件事：</p><ul><li><p>通过 React.createContext <strong>创建多个 Context 对象</strong>；</p></li><li><p>将这些 Context 对象的 Provider 组件挂载到一个 Providers 上一起 export；</p></li><li><p>在 Providers 方法中根据业务逻辑分别返回对应的 <strong>Provider 组件，并赋初值</strong>。</p></li></ul><p>上述逻辑以 Provider 消费者组件为例，Consumer 组件同理。</p><ol start="2"><li><a href="http://211.144.114.26:5088/trunk/danastudio/blob/dev/web/src/routes/Workflow/WorkflowIDE.js#L1241" target="_blank" rel="noopener">./Workflow/WorkflowIDE.js</a></li></ol><p><img src="../images/context/05.png" alt="图5"></p><p>在上层组件 WorkflowIDE 中，调用 Context.Provider 组件并赋初值。这个组件是整个工作流工作区的顶层组件，其内部嵌套很多 Consumer 子组件，诸如：</p><ul><li>./WorkflowOnlineForm.js</li><li>./WorkflowCreateForm.js</li><li>./flow-components/AccDataX.js</li><li>……</li></ul><p><img src="../images/context/06.png" alt="图6-1"> <img src="../images/context/07.png" alt="图6-2"></p><p>那么在这些 Consumer 消费者子组件中，通过获取 context 透传的值，去做业务逻辑的处理。比如在创建脚本表单组件中就是这样使用 Consumer 的。</p><p><img src="../images/context/08.png" alt="图7"></p><p>到这里，相信看过工作流代码的同学对于工作流模块的数据流管理方式已经有了一个大方向上的认识，不至于再为工作流深层嵌套组件间无法找到如何传值的方式而头晕。</p><p>综合之前我分享讨论的几个话题：render props、hooks（，甚至于 refs），他们和 Context 似乎都涉及到数据管理。在 Context API 里，Cunsumer 子组件使用 context 的方式就与 render props 很相似，它们都会通过使用一个函数来返回最终的 React 节点，并调用 Provider 父组件的 context 值进行数据渲染。</p><h2 id="Context-API"><a href="#Context-API" class="headerlink" title="Context API"></a>Context API</h2><h3 id="旧-Context-API-的缺陷"><a href="#旧-Context-API-的缺陷" class="headerlink" title="旧 Context API 的缺陷"></a>旧 Context API 的缺陷</h3><p>在 Context 早期的版本中定义 Context 组件需要先定义 <em>childContextTypes</em> <em>、getChildContext</em> 才能把 context 传递下去。同时接收组件也要先定义 <em>contextTypes</em> 才能读取到数据，否则即使父组件 Context 中定义了数据，子组件 Context 也会为 _undefined_。</p><p>虽然功能上实现了跨层级数据透传，但本质上还是需要一层一层反复声明如何读取 state，没有真正避免层级嵌套带来的效率问题。</p><p>那么不可避免地，这种写法会受到状态阻断的影响，当某一个传递组件的 context 发生变化时，如果其中一个中间件的 <strong>shouldComponentUpdate</strong> 方法返回 false，那么其后所有组件都不再接受到 context 的变化从而触发 rerender。</p><p>旧的 Context API：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * codesanbox: https://codesandbox.io/s/silly-tu-00dec</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PureComponent &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; PropTypes &#125; <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">DeliverComponent</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  getChildContext() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">      color: <span class="string">"#fff"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MidComponent</span> /&gt;</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="xml">  &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="xml">&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="xml">DeliverComponent.childContextTypes = &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="xml">  color: PropTypes.string</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="xml">&#125;;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="xml">const MidComponent = props =&gt; <span class="tag">&lt;<span class="name">ReceiverComponent</span> /&gt;</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="xml">const ReceiverComponent = (props, context) =&gt; (</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> <span class="attr">context.color</span> &#125;&#125;&gt;</span>接收组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="xml">);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="xml">ReceiverComponent.contextTypes = &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="xml">  color: PropTypes.string</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="xml">&#125;;</span></span></pre></td></tr></table></figure><h2 id="新-Context-API-的应用"><a href="#新-Context-API-的应用" class="headerlink" title="新 Context API 的应用"></a>新 Context API 的应用</h2><ul><li><strong>React.createContext</strong></li></ul><p>创建 Context 对象。用于提供 Provider 和 Consumer 子组件。</p><ul><li><strong>Context.Provider</strong></li></ul><p>Context 对象提供的生产者组件，相当于父组件。通过赋初值，将 state、props 分发给属于该 Provider 的所有 Consumer。</p><p>这里主要与旧版的 Context API 作对比，相当于 getChildContext() 方法。</p><p><strong>注意，Provider 组件并不是必须的</strong>，可以不使用 Context.Provider，Consumer 消费者子组件也能够订阅 Context 的值的变化。只不过此处 Consumer 组件获取到的是 Context 创建时的默认值 defaultValue。</p><ul><li><strong>Class.contextType</strong></li></ul><p>将 Context 对象挂载到 Class 上，contextType 这个属性会接受上面创建的 Context 对象实例，这样就可以在 Class 中的任何生命周期函数甚至于 render() 方法中通过 this.context 来访问 Provider 的数据。</p><ul><li>Context.Consumer</li></ul><p>Context 对象自身提供的 Consumer 组件能够订阅到 context 的变化。<br>在这个组件中，可以直接通过获取到的 context 的值，来完成后续的业务操作，如通过 children 函数读取 value 去遍历列表，返回一个 React 节点。这一点类似于 render props。</p><p><strong>新 Context API：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * codesanbox: https://codesandbox.io/s/silly-tu-00dec</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PureComponent &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DEFAULT_VALUE = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  color: <span class="string">"#f83431"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个唯一 Context</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> IDEContext = React.createContext(DEFAULT_VALUE);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MidComponent = <span class="function"><span class="params">props</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">ReceiveComponent</span> /&gt;</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="xml">// Consumer 子组件通过透传的 context 值进行渲染</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="xml">const ReceiveComponent = props =&gt; (</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  &lt;IDEContext.Consumer&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#123;context =&gt; &lt;div style=&#123;&#123; color: context.color &#125;&#125;&gt;接收 Context&lt;/div&gt;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">IDEContext.Consumer</span>&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="xml">);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="xml">export default class DeliverComponent extends PureComponent &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="xml">  state = &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="xml">    color: "#fff"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="xml">  &#125;;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="xml">  render() &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="xml">    return (</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">      &lt;IDEContext.Provider value=&#123;this.state&#125;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        &lt;MidComponent&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">          &lt;ReceiveComponent /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        &lt;/MidComponent&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">IDEContext.Provider</span>&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"><span class="xml">    );</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="xml">  &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"><span class="xml">&#125;</span></span></pre></td></tr></table></figure><p><strong>新的 API 在数据传递过程中不会被 shouldComponentUpdate 阻断</strong>，因为它不再需要一层一层声明 Context 上定义的属性值，我们只需要关注 Provider 中的 store 的变化。</p><h2 id="Context-在-React-Router-中的应用"><a href="#Context-在-React-Router-中的应用" class="headerlink" title="Context 在 React-Router 中的应用"></a>Context 在 React-Router 中的应用</h2><p>react-router 实现路由管理所使用的几个核心组件 <code>&lt;Router /&gt;</code>、<code>&lt;Route /&gt;</code>、<code>&lt;Link /&gt;</code>、<code>&lt;Redirect /&gt;</code> 等，就是通过使用 Contex 在这些组件之间共享 router 数据来完成的。</p><p>可以翻阅 <a href="https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules" target="_blank" rel="noopener">react-router</a> 源码，进一步了解其设计思想。</p><ol><li><a href="https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/RouterContext.js" target="_blank" rel="noopener">RouterContext.js</a></li></ol><p>RouterContext.js 创建并导出了一个名为 context 的 Context，预留给 Router、Route 使用。</p><p><img src="../images/context/09.png" alt="图8"></p><ol start="2"><li><a href="https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/Router.js" target="_blank" rel="noopener">Router.js</a></li></ol><p><code>&lt;Route /&gt;</code>作为子组件必须嵌套在<code>&lt;Router /&gt;</code>中使用，所以 <code>&lt;Router /&gt;</code> 作为生产者 Provider 组件，核心思想就是为子组件提供一个带有 router 属性的 Context，同时监听 history，一旦 history 发生变化，便通过 setState()触发组件重新渲染。</p><p><img src="../images/context/10.png" alt="图9-1"> <img src="../images/context/11.png" alt="图9-2"></p><ol start="3"><li><a href="https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/Route.js" target="_blank" rel="noopener">Route.js</a></li></ol><p>所以，<code>&lt;Route / &gt;</code>组件作为 Consumer Component，通过从 RouterContext 的 Provider 提供的 context 值，返回一个 children function，去渲染路由数据。</p><p><img src="../images/context/12.png" alt="图10-1"> <img src="../images/context/13.png" alt="图10-2"></p><h2 id="Redux-与-Context"><a href="#Redux-与-Context" class="headerlink" title="Redux 与 Context"></a>Redux 与 Context</h2><p>redux 的状态管理遵循单一数据流的模式，外部事件通过调用 dispatch 发起 action 到 recuder 中更新 state。react-redux 核心内容包含两个部分：Provider 组件、connect 函数，其中：</p><ol><li><p><strong>Provider</strong> 组件将全局唯一的数据源 <strong>store 注入到 context 中</strong>；</p></li><li><p><strong>connect</strong> 方法<strong>把 Context 中由 Provider 注入的 store 取出，并通过 props 分发到子组件中</strong>，从而使得子组件能够获取到 redux 中的 store 数据。</p></li></ol><p>react-redux 的源码我没有仔细翻读，但其大致思想和上述 react-router 类似，这里贴上 Provider.js 组件的部分核心代码供参阅：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * react-redux: Provider.js 核心源码</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">super</span>(props);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> &#123; store &#125; = props; <span class="comment">// 全局 store</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.state = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">      store,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">      subscription</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.previousState = store.getState();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  componentDidMount() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.state.subscription.trySubscribe();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.previousState !== <span class="keyword">this</span>.props.store.getState()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">this</span>.state.subscription.notifyNestedSubs();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  componentWillUnmount() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.unsubscribe) <span class="keyword">this</span>.unsubscribe();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.state.subscription.tryUnsubscribe();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">  render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> Context = <span class="keyword">this</span>.props.context || ReactReduxContext;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">      &lt;Context.Provider value=&#123;<span class="keyword">this</span>.state&#125;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        &#123;<span class="keyword">this</span>.props.children&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">      &lt;<span class="regexp">/Context.Provider&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    );</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">  &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">/</span><span class="regexp">/ ...</span></span></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>React 中可以通过 Context 进行数据透传，避免了父子级层层传递 props。那么<br>使用 Context 如何从子级向父级进行跨组件数据透传？</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>相比 props 和 state，React 的 Context 可以实现跨层级的组件通信。</p></li><li><p>Context API 的使用基于生产者消费者模式。生产者一方，通过组件静态属性 childContextTypes 声明，然后通过实例方法 getChildContext()创建 Context 对象。消费者一方，通过组件静态属性 contextTypes 申请要用到的 Context 属性，然后通过实例的 context 访问 Context 的属性。</p></li><li><p>合理适当使用 Context。如果可以做到保证 Context 的可控性、耦合性在合理范围内，可以考虑使用。</p></li><li><p>……</p></li></ul><p>其他诸如上述 Context 的优缺点、特性等内容。</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><ol><li><a href="https://reactjs.org/docs/context.html#api" target="_blank" rel="noopener">React 官网</a> - Context API</li><li><a href="https://zhuanlan.zhihu.com/p/50336226" target="_blank" rel="noopener">避免 React Context 导致的重复渲染</a> - 程墨 Morgan [知乎]</li><li><a href="https://zhuanlan.zhihu.com/p/33925435" target="_blank" rel="noopener">从新的 Context API 看 React 应用设计模式</a> - 诚身 [知乎]</li><li><strong><a href="https://zapier.com/engineering/how-to-build-redux/" target="_blank" rel="noopener">Build Yourself a Redux</a></strong> - Justin Deal [zapier]</li><li><a href="https://zhuanlan.zhihu.com/p/20381597" target="_blank" rel="noopener">深入理解 react-router 路由系统</a> - 范洪春 [知乎]</li><li><a href="https://juejin.im/post/5cf5d24d6fb9a07eb55f4802" target="_blank" rel="noopener">你不必使用 Redux：比较 prop 钻取、Redux 和 React Context API</a> - Ioodu [知乎]</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;React 使用单向数据流的设计模式进行数据管理，也就是说父子组件间的数据通信需要依靠 state 或 props 进行传递。如果你的组件层
      
    
    </summary>
    
    
      <category term="原创" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="技术栈" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="设计模式" scheme="https://henery002.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="状态管理" scheme="https://henery002.github.io/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    
      <category term="数据分发" scheme="https://henery002.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Refs转发</title>
    <link href="https://henery002.github.io/2019/06/05/7.%20Refs%E8%BD%AC%E5%8F%91/"/>
    <id>https://henery002.github.io/2019/06/05/7.%20Refs%E8%BD%AC%E5%8F%91/</id>
    <published>2019-06-05T02:00:00.000Z</published>
    <updated>2020-02-16T10:39:10.153Z</updated>
    
    <content type="html"><![CDATA[<p>React 中的 refs 提供了一种访问 render() 方法中创建的 React 元素的方法。虽然 React 的使用思想是通过传入 props 或 state 进行状态管理进而重新渲染组件，不提倡强行修改 DOM 元素，但在某些场景和需求下，访问 DOM 节点不可避免，是从 DOM 元素读取数据的好方法。</p><h2 id="在-React-中使用-Refs-的四种方式"><a href="#在-React-中使用-Refs-的四种方式" class="headerlink" title="在 React 中使用 Refs 的四种方式"></a>在 React 中使用 Refs 的四种方式</h2><h3 id="String-refs"><a href="#String-refs" class="headerlink" title="String refs"></a>String refs</h3><p>ref 的字符串属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> ref=<span class="string">"textInput"</span> /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 然后在组件中可以通过 this.refs.textInput.value 获取到该DOM节点的值</span></span></pre></td></tr></table></figure><p>这种设置 refs 的方式已经过时。在配置了 eslint 的项目中使用时将会抛出错误提示，应该避免使用这个废弃的 API。</p><h3 id="回调引用（callback-refs）"><a href="#回调引用（callback-refs）" class="headerlink" title="回调引用（callback refs）"></a>回调引用（callback refs）</h3><p><strong><u>给 DOM 元素添加 ref 属性</u></strong></p><p>在项目中常用的方式是 refs 回调。即为 ref 属性设置回调函数，当设置 ref 时，React 会调用这个函数，并将 element 作为第一个参数传递给该函数。</p><p>贴一个常用的案例。该示例用于获取 input 标签的文本值，使用回调函数的方式引入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">super</span>(props);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.textInput = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.setTextInputRef = <span class="function"><span class="params">element</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">this</span>.textInput = element; <span class="comment">// 将element赋值给 this.textInput</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  handleSubmit = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    e.preventDefault();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.textInput.value);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">      &lt;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        &lt;input type=<span class="string">"text"</span> ref=&#123;<span class="keyword">this</span>.setTextInputRef&#125; /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 或者写成</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        &lt;input type=<span class="string">"text"</span> ref=&#123;ele =&gt; <span class="keyword">this</span>.eleInput = ele&#125;&gt; <span class="comment">// ele 即指向当前input元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        &lt;button onClick=&#123;e =&gt; <span class="keyword">this</span>.handleSubmit(e)&#125;&gt;提交&lt;<span class="regexp">/button&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>当组件被挂载时 React 会将这个 DOM 元素传递给 ref 的回调函数，element 作为 DOM 元素的实例被赋值给 this.textInput。</p><p><strong><u>给类组件添加 ref 属性</u></strong></p><p>如果给 class 声明的组件添加 ref 属性，则 ref 回调的参数将指向已经加载的该组件的实例。这种方式区别于下面将要讲到的函数式组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="xml">  &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="xml">&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="xml">class Fn extentds React.Comonent &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="xml">  render() &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    return &lt;Foo ref=&#123;ele =&gt; &#123; this.componentEle = ele; console.log(ele) &#125;&#125; /&gt;;   // ele指向当前组件的实例</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><strong><u>refs 与函数式组件</u></strong></p><p>ref 属性不能用在函数式声明的组件上，因为函数式组件不能被实例化。如以下 ref 赋值方式无效并且会报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">InputText</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    &lt;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">      &lt;input type=<span class="string">"text"</span> /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &lt;<span class="regexp">/div&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">  );</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="regexp"></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">class MyComponent extends React.Component &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">  render() &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    /</span><span class="regexp">/ ref 无效且报错</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    return (</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">      &lt;InputText</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">        ref=&#123;el =&gt; &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">          this.componEle = el;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">        &#125;&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">      /</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>但是在函数式组件内部依然可以使用 ref 属性。</p><h3 id="React-createRef"><a href="#React-createRef" class="headerlink" title="React.createRef()"></a>React.createRef()</h3><p>React 提供了 creatRef()函数来创建 Refs，并通过该方法将 ref 属性附加到 React 组件的 DOM 元素上。</p><p>比如，我们在组件的构造函数中创建一个 ref 实例，使其在整个组件内可用，并将其赋值给 this.firstRef，然后在 render()方法内部，将创建的 ref 示例传递给 HTML 元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">super</span>(props);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.firstRef = React.createRef();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.firstRef&#125;</span> /&gt;</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="xml">  &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="xml">&#125;</span></span></pre></td></tr></table></figure><p>通过这种方式创建 ref，我们可以重构一些现有的业务场景。</p><p>来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">super</span>(props);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 创建一个ref实例</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.textInput = React.createRef();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  focusTextInput() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 当 ref 属性被render()方法中的HTML元素使用时，上述创建的ref实例会接收来自底层DOM元素的 current 值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.textInput.current.value);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.textInput.current.focus();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 将在构造函数中创建的ref示例传递到 input 组件的 ref 属性上</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">      &lt;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        &lt;input type=<span class="string">"text"</span> ref=&#123;<span class="keyword">this</span>.textInput&#125; /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &lt;input</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">          type=<span class="string">"button"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">          value=<span class="string">"Focus the text input"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">          onClick=&#123;<span class="keyword">this</span>.focusTextInput&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">      &lt;<span class="regexp">/div&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    );</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">  &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">&#125;</span></span></pre></td></tr></table></figure><p>这里有一个 current 属性，它就是 input DOM 元素对象本身（是一个 DOM 对象），所以，要获取 input 标签的实际值（或者其方法属性），必须要使用 this.textInput.current.value 方式。</p><p>React.createRef 主要是结合 React.forwardRef 方法实现 refs 的转发，来看下面的例子。</p><h3 id="转发-refs（Forwarding-refs）"><a href="#转发-refs（Forwarding-refs）" class="headerlink" title="转发 refs（Forwarding refs）"></a>转发 refs（Forwarding refs）</h3><p>React 提供的 Ref forwarding 方案用来将 ref 通过组件传递给其子节点。这种场景对于可复用组件库和高阶组件很有用。</p><p>也就是说，可以使用 React.forwardRef 函数将 ref 转发到组件中，Ref forwarding 允许组件接收一个 ref，并将它向下传递 / 转发（用来点题）给子组件。</p><p>一个栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TextInput = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  &lt;input type=<span class="string">"text"</span> placeholder=<span class="string">"请输入表名"</span> ref=&#123;ref&#125; /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inputRef = React.createRef();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  handleSave = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(inputRef.current.value);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">      &lt;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        &lt;TextInput ref=&#123;inputRef&#125; /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleSave&#125;&gt;保存&lt;<span class="regexp">/button&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>总结起来说，就是：</p><ol><li>使用 React.createRef() 创建一个 ref 实例（inputRef）；</li><li>将 ref 实例指定给组件（TextInput）的 ref 属性 ;</li><li>React.forwardRef()方法将 ref 实例作为其回调函数的第二个参数向下转发给底层 DOM 组件（<strong><code>&lt;input ref={ref} /&gt;</code></strong>）；</li><li>在外层组件中能够通过 current 对象访问 DOM 节点值。</li></ol><blockquote><p>注：这里的外层组件是 CustomTextInput 相对于 InputText 而言。</p></blockquote><h2 id="在高阶组件中转发-Refs"><a href="#在高阶组件中转发-Refs" class="headerlink" title="在高阶组件中转发 Refs"></a>在高阶组件中转发 Refs</h2><p>另外在 React Refs 的官方文档中还讲到了在高阶组件（HOC）中转发 refs，这里也顺便了解一下。不过我目前还没有在项目中实际使用过，但对于高阶组件而言很有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Input = <span class="function"><span class="params">InputComponent</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> forwardRef = <span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> onChange = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(ref.current.value);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">InputComponent</span> <span class="attr">forwardedRef</span>=<span class="string">&#123;ref&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="xml">  &#125;;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="xml">  return React.forwardRef(forwardRef);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="xml">&#125;;</span></span></pre></td></tr></table></figure><p>这个 Input 高阶组件接收一个 InputComponent 组件作为参数，forwardRef 函数会返回 InputComponent，函数中包含的 ref 参数是由 React.forwardRef() 方法创建的。<strong>这个高阶组件最终会把包装好的组件作为值返回。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 待包装子组件 InputCompoment</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 forwardedRef 下发给 ref 属性，在render()方法中，input输入框就会接收到这个 ref</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TextInput = <span class="function">(<span class="params">&#123; forwardedRef, children, ...rest &#125;</span>) =&gt;</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &lt;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &lt;input ref=&#123;forwardedRef&#125; &#123;...rest&#125; /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#123;children&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  &lt;<span class="regexp">/div&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">);</span></span></pre></td></tr></table></figure><p>可以这样使用这个高阶组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 TextInput 传入 Input 高阶组件，会返回一个 InputField component</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> InputField = Input(TextInput);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 依然使用该方法创建一个 ref 实例，并作为参数传递给 InputFIeld 组</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> inputRef = React.createRef();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">InputField</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> /&gt;</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="xml">  &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="xml">&#125;</span></span></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>refs 的实际项目中的使用场景并不是很多，也不是必须要用到的技术点，只是有时候在特定场景下使用将会便于开发（如操作 input 控件的值与状态改变、触发某些动画等）。</p><p>这里只是作为技术复盘，盘点一下 React Refs 的使用方式，温故而知新。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li>React 中文文档 - Refs 转发</li><li>深入理解 React 虚拟 DOM</li><li>React 中的 Refs &amp; DOM</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;React 中的 refs 提供了一种访问 render() 方法中创建的 React 元素的方法。虽然 React 的使用思想是通过传入 props 或 state 进行状态管理进而重新渲染组件，不提倡强行修改 DOM 元素，但在某些场景和需求下，访问 DOM 节点不可避
      
    
    </summary>
    
    
      <category term="原创" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="技术栈" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Refs" scheme="https://henery002.github.io/tags/Refs/"/>
    
      <category term="DOM" scheme="https://henery002.github.io/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发</title>
    <link href="https://henery002.github.io/2019/04/17/6.%20%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    <id>https://henery002.github.io/2019/04/17/6.%20%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</id>
    <published>2019-04-17T04:01:05.000Z</published>
    <updated>2020-02-21T07:19:07.025Z</updated>
    
    <content type="html"><![CDATA[<p>本文将结合小程序示例项目源码，通过在手机微信客户端实时编译预览，交流学习小程序开发的流程、架构、语法与开放 API 等内容。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>小程序（Mini Program）是一种新的开放能力，是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用。</p></blockquote><h3 id="小程序发展史"><a href="#小程序发展史" class="headerlink" title="小程序发展史"></a>小程序发展史</h3><p>2016 年 9 月 21 日，微信小程序开启内测。腾讯云上线微信小程序解决方案，提供小程序在云端服务器的技术方案。</p><p>2017 年 1 月 9 日，张小龙在 2017 微信公开课上宣布小程序正式上线。</p><p>2017 年 3 月，小程序面向个人开发者开放注册。</p><p>2017 年 12 月 28 日，微信小游戏上线 – 全民娱乐的微信《跳一跳》。</p><p>2018 年，微信小程序陆续更新升级功能，其中包括支持自定义小程序菜单栏等区域的页面风格、开放“附近小程序”、支持小程序投放广告、开发“功能直达”（微信 – 附近的商家）、开发者工具支持真机调试等。</p><p>……</p><p>小程序迭代更新的两年多时间，无论从社区生态、技术架构、云端开发，还是开发者工具等方面来看，都有了质的飞跃，也让普通开发者能够快速上手，定制企业级或者属于个人的小程序。</p><h3 id="小程序与公众号"><a href="#小程序与公众号" class="headerlink" title="小程序与公众号"></a>小程序与公众号</h3><p>微信公众号开发者需要懂得一门服务器端语言（如 php、java、.net、nodejs）而对于前端开发人员来说，上手微信小程序开发没有任何门槛。</p><p>有关小程序前世今生的文案内容可以自行百度，不再赘述。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>小程序开发流程主要分为四步：</p><ul><li>账号注册</li><li>信息完善</li><li>开发</li><li>提交审核与发布</li></ul><h3 id="申请账号"><a href="#申请账号" class="headerlink" title="申请账号"></a>申请账号</h3><ol><li>在<a href="mp.weixin.qq.com">微信公众平台</a>注册小程序账号，填写登记信息。<br><img src="../images/wechat/01.png" alt="图一"></li></ol><blockquote><p>注：1. 用于注册的邮箱账必须未被微信公众平台注册，未被微信开放平台注册、未被个人微信号绑定。2. 每个邮箱只能申请一个小程序账号。</p></blockquote><ol start="2"><li>注册后登陆微信公众平台，需要使用微信扫码验证身份后登陆。<br><img src="../images/wechat/02.png" alt="图二"></li></ol><blockquote><p>注：登录的时候需要使用小程序身份的账号，这里区别于微信公众号身份的账号。</p></blockquote><ol start="3"><li>完善小程序主体的相关设置信息。<br><img src="../images/wechat/03.png" alt="图三"></li></ol><p>每个小程序都拥有一个 AppID，作为小程序的唯一标识。这个 AppID 可以用来在微信公众平台的其他身份账号中关联你已发布的微信小程序，或者在微信中搜索你的小程序。</p><ol start="4"><li>在提交审核与发布环节，需要为小程序配置页面功能。<br><img src="../images/wechat/04.png" alt="图四"> <img src="../images/wechat/05.png" alt="图五"></li></ol><h3 id="安装开发者工具"><a href="#安装开发者工具" class="headerlink" title="安装开发者工具"></a>安装开发者工具</h3><p>在<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html?t=19041921" target="_blank" rel="noopener">开发者工具</a>下载页面，选择下载版本。<br><img src="../images/wechat/06.png" alt="图六"></p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>开发者可以选择导入既有项目，也可以选择创建新项目。</p><p>创建新项目时，需要填入申请小程序账号时生成的 AppID。如果没有 AppID，也可以使用测试号体验小程序的开发，只不过这种模式下很多功能的使用将会受到限制，比如无法使用云服务。</p><p>开发者工具在近两年来不断的更新中，逐渐集成了一整套开发流程完备的架构，包括模拟器（界面）、编辑器（IDE）、调试器（控制台），同时支持版本控制、二维码编译、实时编译等，极大方便了开发者的开发体验。</p><p>初始化项目会生成一套项目配置文件，下面会逐一介绍各个模块配置文件的主要配置方式及作用。<br><img src="../images/wechat/07.png" alt="图七"></p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>小程序中原生组件的使用方式和 html 相似，也有着相似的属性。这里只列出原生组件的名称，相关使用方式、属性可以自行查阅开发者文档。</p><h3 id="基础组件（native-component）"><a href="#基础组件（native-component）" class="headerlink" title="基础组件（native-component）"></a>基础组件（native-component）</h3><ul><li>视图容器</li></ul><ol><li>cover-image 图片容器</li><li>cover-view</li><li>movable-area</li><li>movable-view</li><li>scroll-view</li><li>swiper 滑块视图容器</li><li>swiper-item</li><li>view 视图容器</li></ol><ul><li>基础内容</li></ul><ol><li>icon</li><li>progress</li><li>rich-text</li><li>text</li></ol><ul><li>表单组件</li></ul><ol><li>button</li><li>checkbox</li><li>checkbox-group</li><li>form</li><li>input</li><li>label</li><li>picker</li><li>picker-view</li><li>picker-view-column</li><li>radio</li><li>radio-group</li><li>slider</li><li>switch</li><li>textarea</li></ol><ul><li>导航</li></ul><ol><li>functional-page-navigator</li><li>navigator 页面链接</li></ol><ul><li>媒体组件</li></ul><ol><li>audio</li><li>camera</li><li>image</li><li>live-player 实时音视频播放</li><li>live-pusher 实时音视频录制</li><li>video</li></ol><ul><li>map 地图 API</li></ul><ol><li>map</li><li>canvas 画布</li><li>canvas</li></ol><ul><li>其他</li></ul><ol><li>add Banner 广告</li><li>open-data 用于展示微信开放的数据</li><li>……</li></ol><h3 id="自定义组件（custom-component）"><a href="#自定义组件（custom-component）" class="headerlink" title="自定义组件（custom-component）"></a>自定义组件（custom-component）</h3><p>我们也可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用，或者将复杂的页面拆分成多个低耦合的模块，有助于代码维护。</p><p>这一点类似于 React 的组件化思想。其使用方法也和基础组件（即原生组件）非常相似。限于篇幅的原因，这里不多做描述，查看更多信息，请移步 自定义组件 。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>以创建一个具备云开发功能的 QuickStart 项目为例：</p><p>小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。</p><p>一个小程序的主体部分由三个文件组成，他们必须放置在项目根目录。</p><ol><li>app.js</li><li>app.json</li><li>app.wxss</li></ol><p>每个小程序页面模块有四个文件构成：</p><ol><li>js</li><li>json</li><li>wxml</li><li>wxss</li></ol><blockquote><p>注意：为了减少开发者进行复杂冗余的配置项，描述页面模块的四个文件必须具有相同的路径与名称。</p></blockquote><p><img src="../images/wechat/08.png" alt="图八"></p><h3 id="代码构成"><a href="#代码构成" class="headerlink" title="代码构成"></a>代码构成</h3><p>在上面创建的项目中，可以看到有以下几种类型的文件：</p><ol><li><p>.json，<strong>JSON 配置文件</strong></p><ol><li><p>app.json 是当前小程序的全局配置文件。主要配置小程序的所有页面路由、页面样式、底部 Tab 切换等。主要配置项有 pages、window、tabBar、sitemapLocation 等字段，具体作用将结合代码讲解。<br><img src="../images/wechat/09.png" alt="图九"></p></li><li><p>project.config.json 是开发者工具的个性化配置。开发者可以针对自己的喜好对开发工具做一些界面样式、编译等的配置。</p></li><li><p>页面组件中的 page.json，作用和 app.json 类似。app.json 用来配置小程序全局的一些样式风格色调，但当开发者想要在某模块页面中设置自定义风格时，就可以通过 page.json 配置该模块页面的一些属性，用以覆盖改写全局配置属性。</p></li></ol></li><li><p>.wxml，<strong>WXML 模板文件</strong><br>作用、语法类同于 HTML，但原生标签不同于 HTML。微信小程序有自己专属的原生标签、标签属性以及 js 表达式语法，后面的章节将会详细介绍。</p></li><li><p>.wxss，<strong>WXSS 样式文件</strong><br>同 css 样式文件。但小程序新增了尺寸单位 rpx。开发者不在需要针对手机设备屏幕的不同宽度做一些复杂换算，这些工作将交由小程序底层来做。<br>wxss 有全局样式和局部样式的概念，其用法和上面讲到的 app.json / page.json 的区别与用法相同。</p></li><li><p>.js，<strong>JS 脚本文件</strong><br>开发者还可以利用小程序提供的丰富的 API，开发一些常用的业务场景，如获取用户信息、本地存储、微信支付、生成小程序吗、扫描二维码等等。<br><img src="../images/wechat/10.png" alt="图十"></p></li></ol><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ul><li><strong>全局配置</strong><br>app.json，以小程序示例项目代码为例：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"pages"</span>: [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"page/component/index"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"page/component/pages/view/view"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"page/cloud/pages/scf-storage/scf-storage"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  ],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"window"</span>: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"navigationBarTextStyle"</span>: <span class="string">"black"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"navigationBarTitleText"</span>: <span class="string">"演示"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"navigationBarBackgroundColor"</span>: <span class="string">"#F8F8F8"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"backgroundColor"</span>: <span class="string">"#F8F8F8"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"tabBar"</span>: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"color"</span>: <span class="string">"#7A7E83"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"selectedColor"</span>: <span class="string">"#3cc51f"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"borderStyle"</span>: <span class="string">"black"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"backgroundColor"</span>: <span class="string">"#ffffff"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"list"</span>: [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">      &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"pagePath"</span>: <span class="string">"page/component/index"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"iconPath"</span>: <span class="string">"image/icon_component.png"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"selectedIconPath"</span>: <span class="string">"image/icon_component_HL.png"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"text"</span>: <span class="string">"组件"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">      &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"pagePath"</span>: <span class="string">"page/API/index"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"iconPath"</span>: <span class="string">"image/icon_API.png"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"selectedIconPath"</span>: <span class="string">"image/icon_API_HL.png"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"text"</span>: <span class="string">"接口"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">      &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"pagePath"</span>: <span class="string">"page/cloud/index"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"iconPath"</span>: <span class="string">"image/icon_cloud.png"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"selectedIconPath"</span>: <span class="string">"image/icon_cloud_HL.png"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"text"</span>: <span class="string">"云开发"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"networkTimeout"</span>: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"request"</span>: <span class="number">10000</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"uploadFile"</span>: <span class="number">10000</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"downloadFile"</span>: <span class="number">10000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"cloud"</span>: <span class="literal">true</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"sitemapLocation"</span>: <span class="string">"sitemap.json"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><ul><li><strong>页面配置</strong><br>page/index/index.json，页面模块配置项：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// /page/index页面的json配置项（json中不支持注释）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"navigationBarTitleText"</span>: <span class="string">"小程序官方组件展示"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"navigationBarBackgroundColor"</span>: <span class="string">"#ffffff"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"navigationBarTextStyle"</span>: <span class="string">"black"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"backgroundColor"</span>: <span class="string">"#eeeeee"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"backgroundTextStyle"</span>: <span class="string">"light"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><ul><li><strong>sitemap 配置</strong><br>跟目录下的 sitemap.json 文件用来配置小程序及其页面是否允许在微信内被索引。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"desc"</span>: <span class="string">"some description info..."</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"rules"</span>: [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      <span class="attr">"action"</span>: <span class="string">"allow"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      <span class="attr">"page"</span>: <span class="string">"*"</span> <span class="comment">// 表示所有页面都可以被索引</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="运行机制（逻辑层）"><a href="#运行机制（逻辑层）" class="headerlink" title="运行机制（逻辑层）"></a>运行机制（逻辑层）</h3><p>小程序在原有 JavaScript 的基础上扩展了部分功能，以方便小程序的开发：</p><ol><li>增加 App 和 Page 方法，进行小程序注册和页面注册。</li><li>增加 getApp 和 getCurrentPages 方法，分别用来获取 App 实例和当前页面栈。</li><li>增加 API。</li><li>支持模块化。</li></ol><blockquote><p>注意：小程序框架的逻辑层并非运行在浏览器中，所以 js 在浏览器端的一些特性将无法使用，如 window、document 等。</p></blockquote><ul><li><strong>注册小程序</strong></li></ul><p>每一个小程序都需要在全局 app.js 中调用 App 方法注册小程序实例，并绑定生命周期回调函数、错误监听和页面不存在监听函数等。</p><p>App 方法只能在 app.js 中调用有且仅有一次，这个实例是全部页面共享的。开发者可以在页面模块中<strong>通过 getApp 方法获取到全局唯一的这个实例</strong>，并去调用在实例上注册或声明的函数或变量。</p><p>参数是一个 Object 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// App()</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">App(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  onLaunch(options) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Do something initial when launch.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  onShow(options) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Do something when show.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  onHide() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Do something when hide.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  onError(msg) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(msg);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  globalData: <span class="string">"some datas"</span> <span class="comment">// 用于自定义的变量或函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// getApp()</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// page/index/index.js</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> appInstance = getApp();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(appInstance.globalData); <span class="comment">// some datas</span></span></pre></td></tr></table></figure><ul><li><strong>注册页面</strong></li></ul><p>每个页面模块都需要在对应的 js 文件中调用 Page 方法注册页面实例，指定页面初始化数据、生命周期回调、事件处理函数等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Page(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  data: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    text: <span class="string">"This is page data."</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  onLoad(options) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Do some initialize when page load.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  onReady() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Do something when page ready.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  onShow() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Do something when page show.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  onHide() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Do something when page hide.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  onUnload() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Do something when page close.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">  onPullDownRefresh() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Do something when pull down.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  onPageScroll() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Do something when page scroll</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">  onResize() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Do something when page resize</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">  onTabItemTap(item) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(item.index);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(item.pagePath);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(item.text);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure><ul><li><p><strong>小程序生命周期</strong><br>见上例代码部分。</p></li><li><p><strong>页面路由</strong><br>小程序的路由跳转方式一般包括：初始化、重定向、返回、Tab 切换、重启动。我们可以直接参考开发者文档对页面路由触发方式的定义：</p><p>路由跳转的实例方法参见：<br>小程序示例项目代码 /page/pages/navigator/navigator.js 。<br><img src="../images/wechat/11.png" alt="图十一"></p></li></ul><h3 id="WXML-语法（视图层）"><a href="#WXML-语法（视图层）" class="headerlink" title="WXML 语法（视图层）"></a>WXML 语法（视图层）</h3><ul><li><strong>数据绑定</strong><br>数据绑定使用 Mustache 语法。WXML 中的动态数据全部来自于对应 Page 方法中定义的 data。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// xxx.js</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Page(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  data: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    id: <span class="string">"my_mini_program"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    condition: <span class="string">""</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    message: <span class="string">"Hello MINA!"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure><p>除了内容渲染外、组件属性、控制属性、关键字都需要使用双引号。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&lt;view id=<span class="string">"item-&#123;&#123;id&#125;&#125;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 控制属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&lt;view wx:<span class="keyword">if</span>=<span class="string">"&#123;&#123;condition&#125;&#125;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键字</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&lt;checkbox checked=<span class="string">"&#123;&#123;false&#125;&#125;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">checkbox</span>&gt;</span></span></span></pre></td></tr></table></figure><ul><li><p><strong>列表渲染</strong></p><p><strong>wx:for</strong></p><p>在组件上使用 wx:for 控制属性绑定一个数组，就可以直接使用数组中各项的数据重复渲染该组件。默认数组的当前想的下标变量名默认为 index，数组当前项的变量名默认为 item。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;view wx:<span class="keyword">for</span>=<span class="string">"&#123;&#123;array&#125;&#125;"</span> wx:<span class="keyword">for</span>-index=<span class="string">"idx"</span> ewx:<span class="keyword">for</span>-item=<span class="string">"itemName"</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;&#123;index&#125;&#125;: &#123;&#123;item.message&#125;&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#123;&#123;idx&#125;&#125;: &#123;&#123;itemName.message&#125;&#125;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&lt;<span class="regexp">/view&gt;</span></span></pre></td></tr></table></figure><p><strong>block wx:for</strong><br>类似 block wx:if，也可以将 wx:for 用在<block/>标签上，以渲染一个包含多节点的结构块。例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;block wx:<span class="keyword">for</span>=<span class="string">"&#123;&#123;[1, 2, 3]&#125;&#125;"</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  &lt;view&gt;&#123;&#123; index &#125;&#125;:<span class="xml"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  &lt;view&gt;&#123;&#123; item &#125;&#125;&lt;<span class="regexp">/view&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">&lt;/</span>block&gt;</span></pre></td></tr></table></figure><p><strong>wx:key</strong><br>同 React 中 key 值的概念，小程序中需要使用 wx:key 来指定动态变化的列表渲染数据中 item 的唯一标识符。</p><p>wx:key 的值以两种形式提供</p><ol><li><p>字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。</p></li><li><p>保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字</p></li></ol><blockquote><p>注：如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。</p></blockquote></li><li><p><strong>条件渲染</strong></p><p><strong>wx:if</strong><br>小程序框架中，可以使用 wx:if=”“ 来判断是否渲染该代码块。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;view wx:<span class="keyword">if</span>=<span class="string">"&#123;&#123;condition&#125;&#125;"</span>&gt;Contents&lt;<span class="regexp">/view&gt;</span></span></pre></td></tr></table></figure><p>也可以使用 wx:elif 和 wx:else 来添加一个 else 块。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;view wx:<span class="keyword">if</span>=<span class="string">"&#123;&#123;length &gt; 5&#125;&#125;"</span>&gt;<span class="number">1</span>&lt;<span class="regexp">/view&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">&lt;view wx:elif="&#123;&#123;length &gt; 2&#125;&#125;"&gt;2&lt;/</span>view&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&lt;view wx:<span class="keyword">else</span>&gt;<span class="number">3</span>&lt;<span class="regexp">/view&gt;</span></span></pre></td></tr></table></figure><p><strong>block wx:if</strong></p><p>当控制属性 wx:if 一次性需要判断多个组件标签时，可以使用 <block /> 标签将多个组件报过起来，并在其上使用控制属性 wx:if。但 <block /> 并不是一个组件，只作为一个包裹元素，类似于 React 中的 Fragment。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;block wx:<span class="keyword">if</span>=<span class="string">"&#123;&#123;true&#125;&#125;"</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  &lt;view&gt;&#123;&#123; view &#125;&#125;&lt;<span class="regexp">/view&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">  &lt;view&gt;view2&lt;/</span>view&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&lt;<span class="regexp">/block&gt;</span></span></pre></td></tr></table></figure></li><li><p><strong>模板</strong></p><p>WXML 提供了模板（template）的概念，开发者可以在模板中定义代码片段，在其他不同模块中调用。</p><p>定义一个模板。使用 name 属性作为模板的名称，然后在这个模板内定义代码片段：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;template name=<span class="string">"msgItem"</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  &lt;view&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    &lt;text&gt;...&lt;<span class="regexp">/text&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">  &lt;/</span>view&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&lt;<span class="regexp">/template&gt;</span></span></pre></td></tr></table></figure><p>使用模板。使用 is 属性，声明需要使用的模板，然后将模板所需数据传入到属性中即可。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;template is=<span class="string">"msgItem"</span> data=<span class="string">"&#123;&#123;...item&#125;&#125;"</span> /&gt;</span></pre></td></tr></table></figure><p>开发者也可以使用 is 属性的 Mustache 语法，动态决定具体需要渲染哪些模板内容（即在 is 中做逻辑判断）。同时，模板中只能使用 data 传进来的数据。</p><p>很多时候，模板用来抽取小程序页面页头和页脚的通用组件。</p><br></li><li><p><strong>引用</strong><br>WXML 提供了两种文件引用方式 import 和 include。</p><p><strong>import</strong></p><p>那么上面定义了模板文件，该如何将文件引入到目标组件中呢？可以使用 import 方式。</p><p>比如上述模板 msgItem 是在 item.wxml 中定义的，那么我们如果想要在 index.wxml 文件中引入，只需要这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.wxml</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">import</span> src=<span class="string">"item.wxml"</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&lt;template is=<span class="string">"msgItem"</span> data=<span class="string">"&#123;&#123;...item&#125;&#125;"</span> /&gt;</span></pre></td></tr></table></figure><p><strong>include</strong></p><p>可以简单的将 include 的作用理解成拷贝一份文件到当前位置，但所拷贝的目标文件中的 <code>&lt;template /&gt;</code> 和 <code>&lt;wxs /&gt;</code> 不会被引入。</p><p>例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// header.wxml</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&lt;view&gt;header infos&lt;<span class="regexp">/view&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="regexp"></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">/</span><span class="regexp">/ footer.wxml</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">&lt;view&gt;footer infos&lt;/</span>view&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.wxml</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&lt;include src=<span class="string">"header.wxml"</span> /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&lt;view&gt;body infos&lt;<span class="regexp">/view&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">&lt;include src="footer.wxml" /</span>&gt;</span></pre></td></tr></table></figure></li></ul><h2 id="API-与云开发"><a href="#API-与云开发" class="headerlink" title="API 与云开发"></a>API 与云开发</h2><h3 id="小程序-API-与服务端-API"><a href="#小程序-API-与服务端-API" class="headerlink" title="小程序 API 与服务端 API"></a>小程序 API 与服务端 API</h3><p>小程序开发框架提供了丰富的微信原生 API，可以方便地调用微信提供的能力。如获取用户信息、本地存储、扫码支付等。</p><p>小程序 API 有以下类型：</p><ol><li>事件监听 API</li><li>同步 API</li><li>异步 API</li></ol><p>参阅 API 与 服务端 API，查看小程序的开放接口的具体使用方法。</p><h2 id="云开发"><a href="#云开发" class="headerlink" title="云开发"></a>云开发</h2><ol><li><p>通过开发者工具创建具有云开发功能的 QuickStart 项目，点击工具栏云开发按钮开通云开发功能。<br><img src="../images/wechat/12.png" alt="图十二"></p></li><li><p>创建云开发环境。<br><img src="../images/wechat/13.png" alt="图十三"> <img src="../images/wechat/14.png" alt="图十四"></p></li><li><p>在云开发控制台中使用数据库、存储、云函数功能，查看小程序云端开发运营分析数据。<br><img src="../images/wechat/15.png" alt="图十五"></p></li></ol><h2 id="小程序示例源码分析"><a href="#小程序示例源码分析" class="headerlink" title="小程序示例源码分析"></a>小程序示例源码分析</h2><p>参见源码。</p><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ol><li><a href="https://developers.weixin.qq.com/miniprogram/introduction/index.html" target="_blank" rel="noopener">微信公众平台 - 小程序开发</a></li><li><a href="http://www.wxapp-union.com/portal.php" target="_blank" rel="noopener">小程序社区</a></li><li><a href="https://v.qq.com/x/cover/b86kk0n60chvn5j/b0029zsv8t9.html" target="_blank" rel="noopener">2019 年微信公开课 PRO</a></li><li><a href="https://developers.weixin.qq.com/community/develop/article/doc/000e4a51524570e51278579d656c13" target="_blank" rel="noopener">微信开放社区 - Taro 团队携手云开发搭建电商后台服务</a></li><li><a href="https://www.zhihu.com/question/50907897/answer/785422713" target="_blank" rel="noopener">知乎：如何入门微信小程序开发，有哪些学习资料？</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文将结合小程序示例项目源码，通过在手机微信客户端实时编译预览，交流学习小程序开发的流程、架构、语法与开放 API 等内容。&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;bl
      
    
    </summary>
    
    
      <category term="原创" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="技术栈" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="小程序开发" scheme="https://henery002.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="云开发" scheme="https://henery002.github.io/tags/%E4%BA%91%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>使用components属性对Table二次封装</title>
    <link href="https://henery002.github.io/2019/03/20/5.%20%E4%BD%BF%E7%94%A8components%E5%B1%9E%E6%80%A7%E5%AF%B9Table%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85/"/>
    <id>https://henery002.github.io/2019/03/20/5.%20%E4%BD%BF%E7%94%A8components%E5%B1%9E%E6%80%A7%E5%AF%B9Table%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85/</id>
    <published>2019-03-20T02:00:00.000Z</published>
    <updated>2020-02-16T09:56:26.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>需求：</p><blockquote><p>DanaStudio v4.2 中数据治理 - 标准化：实现两个表格间行数据的拖拽联动效果</p></blockquote><p>效果图：<br><img src="../images/table-components/dnd1.gif" alt="图1"></p><h2 id="由-Table-拖拽排序带来的思考"><a href="#由-Table-拖拽排序带来的思考" class="headerlink" title="由 Table 拖拽排序带来的思考"></a>由 Table 拖拽排序带来的思考</h2><h3 id="一些尝试"><a href="#一些尝试" class="headerlink" title="一些尝试"></a>一些尝试</h3><p>最初曾尝试通过对 Table 组件的 columns 属性进行包裹，以期达到封装 DragSource 和 DropTarget 的效果，但后来发现，antd 根本不会识别这样的修改。</p><p>那么 antd 到底是否开放了一些自定义事件供开发者使用呢？</p><h3 id="官方案例"><a href="#官方案例" class="headerlink" title="官方案例"></a>官方案例</h3><p>antd 官方文档提供了 Table 单一表格的行拖拽排序，并没有暴露出更多可详细配置的 API。</p><p>在拖拽排序的案例中，BodyRow 既是 DragSource，也是 DopTarget。那么既然如此，理应也允许针对 BodyRow 进行二次封装，达到 DragSource 与 DropTarget 的独立，从而实现跨表格的行（row）或列（column）的拖拽。</p><p>在开始本文的探讨之前，先来回顾一下 react dnd 的基础知识。</p><h2 id="React-DnD-回顾"><a href="#React-DnD-回顾" class="headerlink" title="React DnD 回顾"></a>React DnD 回顾</h2><h3 id="什么是-react-dnd"><a href="#什么是-react-dnd" class="headerlink" title="什么是 react dnd"></a>什么是 react dnd</h3><p>React DnD 是一组 React 高阶组件，它可以帮开发者构建复杂的拖放接口，同时保持组件解耦。借助 react dnd 的拖动事件在组件之间传输数据，组件根据拖放事件改变它们的外观和状态（数据）。</p><h3 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h3><p>react-dnd 使用的核心 API 有以下几个：</p><ol><li><strong>DragSource</strong>：用于包装你需要拖动的组件，使组件能够被拖拽。</li><li><strong>DropTarget</strong>：用于包装接收拖拽元素的组件，使组件能够放置。</li><li><strong>DragDropContext</strong>：用于包装拖拽根组件，DragSource 和 DropTarget 都需要包裹在 DragDropContext 内。</li><li><strong>DragDropContextProvider</strong>：与 DragDropContex 类似，用 DragDropContextProvider 元素包裹拖拽根组件。</li></ol><h3 id="API-参数"><a href="#API-参数" class="headerlink" title="API 参数"></a>API 参数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">@DragSource(type, spec, collect)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">@DropTarget(types, spec, collect)</span></pre></td></tr></table></figure><p>DragSource、DropTarget 分别有三个参数：</p><ul><li>type: 拖拽类型，必填。</li><li>spec：拖拽事件的方法对象，必填。</li><li>collect：拖拽过程中需要注入组件的 props 信息，接收两个参数 connect 和 monitor，必填。</li></ul><p>其中：</p><ol><li><strong>type</strong></li></ol><p>当 source 组件的 type 和 target 组件的 type 一致时，target 组件可以接受 source 组件。其值类型可以使 string， symbol，也可以是一个函数来返回该组件的其他 props。</p><ol start="2"><li><strong>spec</strong></li></ol><p>spec 是用来<strong>定义特定方法的一个对象</strong>，如 source 组件的 spec 可以定义拖动相关的事件，target 组件的 spec 可以定义放置相关的事件。具体如下：</p><p><strong>DragSource speObj</strong>：</p><ul><li><strong>beginDrag</strong>(props, monitor, component)</li></ul><p>拖动开始时触发的事件，required。返回与 props 相关的对象。</p><ul><li><strong>endDrag</strong>(props, monitor, component)</li></ul><p>拖动结束时触发的事件，optional。</p><ul><li><strong>canDrag</strong>(props, monitor)</li></ul><p>当前是否可以拖拽的事件，optional。</p><ul><li><strong>isDrag</strong>(props, monitor)</li></ul><p>拖拽时触发的事件，optional。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// DragSource源组件的 spec 属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dragSpec = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  beginDrag(props) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">"%c beginDrag..."</span>, <span class="string">"color: #F8B400"</span>, props);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  endDrag(props, monitor) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> item = monitor.getItem();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> dropResult = monitor.getDropResult();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(item, dropResult, <span class="string">"endDrag..."</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure><p><strong>DropTarget specObj</strong>：</p><ul><li><strong>drop</strong>(props, monitor, component)</li></ul><p>组件被放下时触发的事件，optional。</p><ul><li><strong>hover</strong>(props, monitor, component)</li></ul><p>组件在 DropTarget 上方时响应的事件，optional。</p><ul><li><strong>canDrop</strong>(props, monitor)</li></ul><p>组件可以被放置时触发的事件，可选。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// DropTarget目标组件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetSpec = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  drop(props, monitor) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// dropTarget 行的值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> &#123; record &#125; = props.children[<span class="number">0</span>].props;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// dragSource 行的值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> dragItem = monitor.getItem();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure><p>其中，specObj 这个对象方法中的相关参数为：</p><ul><li>props：组件当前的 props。</li><li>monitor：查询当前的拖拽状态，_<u>比如当前拖拽的 item 和他的 type，当前拖拽的 offsets，当前是否 dropped</u>_。</li><li>component：当前组件的实例。</li></ul><ol start="3"><li><strong>collect</strong></li></ol><p>collect 是一个函数，默认有两个参数：<strong>connect</strong> 和 <strong>monitor</strong>。该函数将返回一个对象，这个对象会<strong>被注入到 props 中</strong>，也就是说，我们<strong>可以在目标组件中通过 this.props 获取到通过 collect 注入进来的所有属性</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO 封装 DropTarget 组件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DropBodyRow = DropTarget(Types.CARD, targetSpec, (connect, monitor) =&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 由 collect 函数返回的对象中的API，可以在组件中利用 this.props 获取</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    connectDropTarget: connect.dropTarget(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    isOver: monitor.isOver(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    canDrop: monitor.canDrop()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;)(BodyRow);</span></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在组件中通过使用 this.props 获取API</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BodyRow</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> &#123; connectDropTarget, isOver, canDrop &#125; = <span class="keyword">this</span>.props;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> connectDropTarget(<span class="xml"><span class="tag">&lt;<span class="name">tr</span> &#123;<span class="attr">...restProps</span>&#125; /&gt;</span>);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="xml">  &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="xml">&#125;</span></span></pre></td></tr></table></figure><p>在 collect 函数的两个参数中：</p><ul><li><p><strong>connect</strong><br>source 组件 的 collect 中的 connect 是 DragSourceConnector 的实例，它内置了两个方法：<strong>dragSource()</strong> 和 <strong>dragPreview()</strong> 。<strong>dragSource() 返回一个方法，将 source 组件传入这个方法，可以将 source DOM 和 React DnD backend 连接起来</strong>；dragPreview() 返回一个方法，可以将其传入节点，作为拖拽预览时的角色。</p><p>target 组件 的 collect 中 connect 是 DropTargetConnector 的实例。<strong>内置的方法 dropTarget() 对应 DragSource()，返回可以将 drop target 和 React DnD backend 连接起来的方法</strong>。</p></li><li><p><strong>monitor</strong><br>monitor 用来<strong>查询当前的拖拽状态</strong>，其对应实例内置了很多方法。由于使用场景不是很必要，这里就不再一一赘述。详情可以移步官网研究。</p></li></ul><p>在熟悉了 React DnD 的相关内容后，来看看如何针对 Table 的 BodyRow 进行二次封装。</p><h2 id="对-Table-Row-二次封装"><a href="#对-Table-Row-二次封装" class="headerlink" title="对 Table Row 二次封装"></a>对 Table Row 二次封装</h2><p>antd3.0 新增了 components 属性，用于覆盖默认的 table 元素。官方更新日志上也只是提供了简单的配置说明，没有详细的案例。</p><h3 id="antd-源码解读"><a href="#antd-源码解读" class="headerlink" title="antd 源码解读"></a>antd 源码解读</h3><p>因为官方文档并没有针对这个属性做过多解释，所以就找到了它的源码来看一哈。<br>在 antd table 的源码中发现，Table 组件在初始化时会调用 createComponents 方法。</p><p><img src="../images/table-components/02.png" alt="图2"></p><p>这个方法最终<strong>在 this.components 上设置了一个 components 对象</strong>。</p><p><img src="../images/table-components/03.png" alt="图3"></p><p>this.components 最终<strong>在 render() 方法中被调用</strong>。</p><p><img src="../images/table-components/04.png" alt="图4"></p><p>定位到 components 属性，不难发现，最终用来覆盖修改 row 或者 column 的，就是它。</p><p><img src="../images/table-components/05.png" alt="图5"></p><p>TableComponent 属性重新定义了表格的 header、body，其中，在我们的场景中所需要的就是 row 属性，将自己用 DropTarget 二次封装好的 BodyRow 组件挂到 components 中。components 属性最终将会在 render()方法中被调用，实现预期效果。</p><p><img src="../images/table-components/06.png" alt="图6"></p><h2 id="拓展案例"><a href="#拓展案例" class="headerlink" title="拓展案例"></a>拓展案例</h2><ol><li><a href="https://codepen.io/raisezhang/pen/MmjypX" target="_blank" rel="noopener">Table 行拖拽排序</a></li><li><a href="https://codepen.io/raisezhang/pen/MoMoyz" target="_blank" rel="noopener">Table 列拖拽排序</a></li><li><a href="https://github.com/ant-design/ant-design/issues/4639" target="_blank" rel="noopener">Table 能否提供拖拽事件或者开放自定义事件</a></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="http://react-dnd.github.io/react-dnd/docs/overview" target="_blank" rel="noopener">React DnD 官方文档</a></li><li><a href="https://segmentfault.com/a/1190000014723549" target="_blank" rel="noopener">React DnD 的使用</a></li><li><a href="https://segmentfault.com/q/1010000012347287" target="_blank" rel="noopener">antd3.0 中新增的 components 属性的使用</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h2&gt;&lt;p&gt;需求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DanaStudio v4.2 中数据治理 - 标准化：实现两个表格间行数据
      
    
    </summary>
    
    
      <category term="原创" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="技术栈" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>React设计模式-Render Props</title>
    <link href="https://henery002.github.io/2019/01/11/4.%20React%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Render-Props/"/>
    <id>https://henery002.github.io/2019/01/11/4.%20React%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Render-Props/</id>
    <published>2019-01-11T03:42:14.000Z</published>
    <updated>2020-02-16T09:56:26.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>React 官方文档对 render props 做出的介绍是这样的：</p><blockquote><p>The term “render prop” refers to a technique for sharing code between React components using a prop whose value is a function.</p></blockquote><p>本文将针对 Render Props 的使用方法，对比高阶组件，简单了解为什么需要使用以及如何正确使用这两种设计模式。</p><h2 id="什么是-Render-Props"><a href="#什么是-Render-Props" class="headerlink" title="什么是 Render Props"></a>什么是 Render Props</h2><p><strong>render props</strong> 是一种<strong>在不重复代码的情况下实现组件共享</strong>的方法。同为 React 的设计模式，render props 与<strong>高阶组件（HOC，Higher-Order Components）</strong>的思想一样，都是为了组件复用以达到<strong>DRY 模式</strong>。</p><p>一个栗子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;DataProvider render=&#123;data =&gt; (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  &lt;h1&gt;Hello &#123;data.target&#125;&lt;<span class="regexp">/h1&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">)&#125;&gt;</span></span></pre></td></tr></table></figure><p>通过使用 props 来定义呈现的内容，组件只起到注入功能，而不需要知道它如何应用于 UI 层。render props 模式意味着用于通过定义单独的组件来传递 props 方法，来指示共享组件应该返回的内容。</p><p>Render Props 的<strong>核心思想</strong>是：通过一个函数将 class 组件的 state 作为 props 传递给纯函数组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SharedComponent  extends React.Component &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  state = &#123;...&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">      &lt;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        &#123;<span class="keyword">this</span>.props.render(<span class="keyword">this</span>.state)&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">      &lt;<span class="regexp">/div&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    )</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">  &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="regexp"></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">export default SharedComponent;</span></span></pre></td></tr></table></figure><p>this.props.render 是由另一个组件传递过来的。为了使用 SharedComponent 组件，可以进行这样的操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SharedComponent <span class="keyword">from</span> <span class="string">"./SharedComponent"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SayHello = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  &lt;SharedComponent render=&#123;state =&gt; <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello, &#123;...state&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125; /&gt;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure><p>其中，{this.props.render(this.state)} 这个函数，将其 state 作为参数传入 props.render 方法中，调用时直接取组件所需的 state 即可。</p><p><strong>值得注意的是：</strong></p><blockquote><p>渲染属性这种设计模式虽然叫作 render props，但是并不一定就要使用 render 这个名字来传递目标渲染函数，开发者可以修改成任意其他名称。</p></blockquote><h2 id="为什么需要-Render-Props"><a href="#为什么需要-Render-Props" class="headerlink" title="为什么需要 Render Props"></a>为什么需要 Render Props</h2><p>搜罗到一个通俗易懂的案例：</p><ul><li><strong>场景一：</strong><br>假设我们正在开发一个电子商务应用程序。它与其他电子商务应用程序一样，向用户显示所有可购买产品，并且用户可以将任何产品添加到购物车。我们将从 API 获取产品数据，并将产品目录显示为卡片列表。</li></ul><p>我们一般会写一个这样的 ProductList 组件来处理这个需求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  state = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    products: []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  componentDidMount() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    getProducts().then(<span class="function"><span class="params">products</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">this</span>.setState(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        products</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">      &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">      &lt;ul&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        &#123;<span class="keyword">this</span>.state.products.map(<span class="function"><span class="params">product</span> =&gt;</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">          &lt;li&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            &lt;span&gt;&#123;product.name&#125;&lt;<span class="regexp">/span&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">            &lt;a href="#"&gt;Add to Cart&lt;/</span>a&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">          &lt;<span class="regexp">/li&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">        ))&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; ProductList &#125;;</span></pre></td></tr></table></figure><ul><li><strong>场景二：</strong><br>在上一个场景中，对于管理员来说，有一个管理门户，他们可以在其中添加或删除产品。在此门户中，要从同一 API 获取产品数据，并以<strong>表格形式</strong>显示产品目录。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductTable</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  state = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    products: []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  componentDidMount() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    getProducts().then(<span class="function"><span class="params">products</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">this</span>.setState(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        products</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">      &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  handleDelete = <span class="function"><span class="params">currentProduct</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> remainingProducts = <span class="keyword">this</span>.state.products.filter(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">      product =&gt; product.id !== currentProduct.id</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    deleteProducts(currentProduct.id).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">this</span>.setState(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        products: remainingProducts</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">      &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">  render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">      &lt;table&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        &lt;thead&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">          &lt;tr&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            &lt;th&gt;Product Name&lt;<span class="regexp">/th&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">            &lt;th&gt;Actions&lt;/</span>th&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">          &lt;<span class="regexp">/tr&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">        &lt;/</span>thead&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        &lt;tbody&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">          &#123;<span class="keyword">this</span>.state.products.map(<span class="function"><span class="params">product</span> =&gt;</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">            &lt;tr key=&#123;product.id&#125;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">              &lt;td&gt;&#123;product.name&#125;&lt;<span class="regexp">/td&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">              &lt;td&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">                &lt;button onClick=&#123;() =&gt; this.handleDelete(product)&#125;&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">                  Delete</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">                &lt;/</span>button&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">              &lt;<span class="regexp">/td&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">            &lt;/</span>tr&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">          ))&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">        &lt;<span class="regexp">/tbody&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">      &lt;/</span>table&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; ProductTable &#125;;</span></pre></td></tr></table></figure><p>现在我们来分析一下：</p><p>上面两个场景都实现了产品数据的获取。但是当出现下述情况时，上面写的两个组件将暴露出弊端：</p><ol><li>在不同场景下必须用不同的方式展示数据时；</li><li>当改为从 localStorage 中访问数据而不是从 API 获取时；</li><li>在产品目录表格中，需要使用具有不同操作的按钮而不都是删除按钮时</li><li>……</li></ol><p>如果每个场景下都手动写一个这个样的组件，那么将有大量冗余的代码。<br>从上面来看，<strong>获取数据</strong>和<strong>显示数据</strong>是两个独立的点，那么我们是不是可以据此分离出独立组件来处理这样的逻辑？</p><p>重构第一个组件 <strong>ProductList</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ProductList = <span class="function">(<span class="params">&#123; products &#125;</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &lt;ul&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      &#123;products.map(<span class="function"><span class="params">product</span> =&gt;</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        &lt;li key=&#123;product.id&#125;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">          &lt;span&gt;&#123;product.name&#125;&lt;<span class="regexp">/span&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">          &lt;a href="#"&gt;Add to Cart&lt;/</span>a&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        &lt;<span class="regexp">/li&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">      ))&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; ProductList &#125;;</span></pre></td></tr></table></figure><p>同理，第二个组件 ProductTable 接收产品数据作为属性，并把数据渲染到表格中。</p><p>现在来创建一个 ProductData 组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductData</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  state = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    products: []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  componentDidMount() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    getProducts().then(<span class="function"><span class="params">products</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">this</span>.setState(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        products</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">      &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 此处应该处理怎样的逻辑？</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; ProductData &#125;;</span></pre></td></tr></table></figure><p>这个组件仍然是从 API 获取数据，逻辑同 <em>ProductList</em> 组件一样。但是在 render 方法中，却不再是调用 <em>ProductList</em> 组件。如果这个组件可以询问开发者需要渲染什么内容，那么问题就会到有效解决。比如在场景一中，我们告诉它要渲染 <em>ProductList</em> 组件，在场景二中让它渲染 <em>ProductTable</em> 组件。</p><p>对于一个组件，会询问它该在什么场景下渲染什么内容，这就是 render props 发挥作用的地方。这种设计思想进一步推动了代码的复用。</p><h2 id="如何使用-Render-Props"><a href="#如何使用-Render-Props" class="headerlink" title="如何使用 Render Props"></a>如何使用 Render Props</h2><p>从概念层面不难理解 render props 的原理，现在来看看以上面的需求为例，该如何应用渲染属性。</p><p>首先我们要<strong>封装一个组件 <em>ProductData</em></strong> （还是上面的案例），通过<strong>属性</strong>传递给该组件一个函数，用来获取产品数据（公共方法），并将这些数据<strong>提供给以属性方式传递进来的函数</strong>。这个传递进来的函数就可以对产品数据做任何场景需求上的操作了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProductData组件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductData</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  state = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    products: []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  componentDidMount() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    getProducts().then(<span class="function"><span class="params">products</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">this</span>.setState(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        products</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">      &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.render(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">      products: <span class="keyword">this</span>.state.products</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; ProductData &#125;;</span></pre></td></tr></table></figure><p>就像前面说的，有了这个组件，我们就需要在不同场景下使用它：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景一</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&lt;ProductData</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  render=&#123;(&#123; products &#125;) =&gt; <span class="xml"><span class="tag">&lt;<span class="name">ProductList</span> <span class="attr">products</span>=<span class="string">&#123;products&#125;</span> /&gt;</span>&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="xml">/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="xml">// 场景二</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&lt;ProductData</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  render=&#123;(&#123; products &#125;) =&gt; &lt;ProductTable products=&#123;products&#125; /&gt;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">/&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">// 场景三</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&lt;ProductData render=&#123;(&#123; products &#125;) =&gt; (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  &lt;h1&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">      Number of Products:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">      &lt;strong&gt;&#123;products.length&#125;&lt;/strong&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  &lt;/h1&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">)&#125; /&gt;</span></pre></td></tr></table></figure><p>这就是 render props 用来构建高度可复用组件的设计思想，它已经成为了一种通用的设计模式。正如之前分享的一篇文章《React 组件解耦》中说的，<strong>渲染属性</strong>和<strong>高阶函数</strong>可以起到同样的作用，甚至可以<strong>相互转化</strong>。</p><h2 id="HOC-设计模式"><a href="#HOC-设计模式" class="headerlink" title="HOC 设计模式"></a>HOC 设计模式</h2><p>限于篇幅的原因，这里简要引入一下高阶组件的设计思想。</p><p>高阶组件本质是一个函数，接收一个组件作为其参数，然后返回一个组件，同时为该组件添加一些额外的功能（有点类似于 ES6 中的装饰器函数）。</p><p>封装一个高阶函数组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数式组件，接收一个组件作为参数，并返回一个新组件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withProductData</span>(<span class="params">WrappedComponent, selectData</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    state = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      products: []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    componentDidMount() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">      getProducts().then(<span class="function"><span class="params">products</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.setState(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">          products</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">      &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">return</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        &lt;WrappedComponent</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">          <span class="comment">// 使用最新的数据渲染组件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">          products=&#123;<span class="keyword">this</span>.state.products&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">          <span class="comment">// 将已有的props属性传递给原组件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">          &#123;...this.props&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">      );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>在高阶组件中数据的获取和状态更新的原理与 render props 一样。只是高阶组件中组件类位于函数内部。这个函数接收一个组件作为参数，然后在内部的 render 方法中渲染这个组件，并且添加额外的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在不同场景下调用高阶组件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ProductListWithData = withProductData(ProductList);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ProductTableWithData = withProductData(ProductTable);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &lt;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">      &lt;ProductListWithData /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">      &lt;ProductTableWithData /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &lt;<span class="regexp">/div</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">  )</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">&#125;</span></span></pre></td></tr></table></figure><h2 id="Render-Props-Vs-HOC"><a href="#Render-Props-Vs-HOC" class="headerlink" title="Render Props Vs HOC"></a>Render Props Vs HOC</h2><p>高阶组件优劣并存：</p><ul><li>支持 ES6；</li><li>复用性强，HOC 是纯函数且返回值还是组件，在使用时<strong>可以多层嵌套</strong>，在不同情境下使用特定的 HOC 组合也便于调试；</li><li>由于是纯函数，<strong>支持传入多个参数</strong>，增强了其适用范围。</li></ul><br><ul><li>当有多个 HOC 一同使用时，无法直接判断子组件的 props 是哪个 HOC 负责传递的；</li><li><strong>重复命名</strong>的问题：若父子组件有同样名称的 props，或使用的多个 HOC 中存在相同名称的 props，则存在覆盖问题，而且 react 也不会报错；</li><li>HOC 的嵌套产生了很多无用的组件，加深了组件层级；</li><li>使用<strong>静态构建</strong>。在上例中，当 ProductListWithData 被创建时，调用了一次 withProductData 中的静态构建。而在 render 中调用构建方法才是 react 所倡导的动态构建思想。此外，在 render 中构建还可以更好地利用 react 的生命周期。</li></ul><p>render props 相较而言，有这些优势：</p><ul><li>同样支持 ES6；</li><li>不用担心 props 的命名问题，在 render 函数中<strong>只取所需要的 state</strong>即可；</li><li>不会产生过多的无用空组件加深层级；</li><li>使用<strong>动态构建</strong>。即所有的改变都在 render 中触发，可以更好地利用 react 的生命周期。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>同样作为 React 的设计模式，个人认为还没有达到谁必须要取代谁的地步。有很多第三方开源库也都使用了这两种设计模式来设计 API 的实现。在实际开发项目中，根据业务需要，选择一种适合自己的方式即可。</p><p>附：<a href="https://github.com/jaredpalmer/awesome-react-render-props" target="_blank" rel="noopener">使用 render props 的开源库</a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li>segmentfault - <a href="https://segmentfault.com/a/1190000013102142" target="_blank" rel="noopener">《render props 从介绍到实践》</a>- Anx</li><li>React 官方文档 - <a href="https://reactjs.org/docs/render-props.html" target="_blank" rel="noopener">《Render Props》</a></li><li><strong><a href="https://www.richardkotze.com/coding/understanding-render-props-react-js" target="_blank" rel="noopener">《Understanding React JS Render Props》</a>- Richard Kotze</strong></li><li><a href="https://www.richardkotze.com/coding/hoc-vs-render-props-react" target="_blank" rel="noopener">《Higher-order components Vs Render Props》</a>- Richard Kotze</li><li>掘金 - <a href="https://juejin.im/post/5ad7ee045188252e93239dd7" target="_blank" rel="noopener">《高阶组件的那些事》</a>- Srtian</li><li>简书 - <a href="https://www.jianshu.com/p/ff6b3008820a?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation" target="_blank" rel="noopener">《React 组件 Render Props VS HOC 设计模式》</a>- Perkin</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;React 官方文档对 render props 做出的介绍是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The te
      
    
    </summary>
    
    
      <category term="原创" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="技术栈" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="设计模式" scheme="https://henery002.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Render Props" scheme="https://henery002.github.io/tags/Render-Props/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks</title>
    <link href="https://henery002.github.io/2018/11/29/3.%20React-Hooks/"/>
    <id>https://henery002.github.io/2018/11/29/3.%20React-Hooks/</id>
    <published>2018-11-29T05:39:57.000Z</published>
    <updated>2021-11-07T13:40:21.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在开始本文的探讨之前，先来看看 React 官网 对 Hooks 做出的介绍：</p><blockquote><p>Hooks are a new feature proposal that lets you use state and other React features without writing a class. They’re currently in React v16.7.0-alpha and …</p></blockquote><h2 id="什么是-Hooks"><a href="#什么是-Hooks" class="headerlink" title="什么是 Hooks"></a>什么是 Hooks</h2><p>Hooks 是 React 函数组件内一类特殊的函数，通常以“use”开头，如“useState”、“useEffect”。Hooks 使得开发者能够在 function component 里继续使用 state 和 life-style，以及使用 custom hook 复用业务逻辑。“Hooks” 的本意是“钩子”，在 React 中，hooks 作为一系列特殊的函数，使函数式组件内部能够“钩住” React 内部的 state 和 life-style。</p><p>React Hooks API 向后兼容，它在解决了一些既有问题的情况下，不仅使开发者能够更好地使用 state 和 life-cycles，真正强大的功能点在于更加轻松地复用组件逻辑，也就是下文将要讲述的 custom hooks。</p><h2 id="Hooks-可以做什么"><a href="#Hooks-可以做什么" class="headerlink" title="Hooks 可以做什么"></a>Hooks 可以做什么</h2><p>React 中函数式组件是一个 pure render component，没有 state 和 component life-cycle。如果开发者需要使用 state 和 life-cycle，就需要将 function component 改写成 class component。在既有的 React API 下，这个模式有一些缺点：</p><ul><li><strong>组件间通信的耦合度高，组件树臃肿</strong><br>在既有的模式下，React 组件间通信有两种模式：</li></ul><ol><li>单向数据流</li><li>通过 Redux 的 global store 实现全局状态和各组件间的解耦</li></ol><p>当有些状态不适合放在 global store 中时，组件间逻辑的复用和通信就变得很困难（只能一层一层往下传）。这一点在高阶组件（HOC, Higher-Order Components）和渲染属性（Render Props）中更为常见。为了复用一些业务逻辑，有时候会单独编写一些高阶组件用来向下传递状态。这样就会导致当开发者的业务规模变得越来越庞大的时候，一些无关 UI 的 wrapper 组件越来越多，React 组件树就会变得愈加臃肿庞杂。例如，在有些时候，一个简单的 Tooltip component 里面都潜藏了很多层额外的组件，使得开发和调试的效率变得低下。</p><p>在新的 React Hook 中，开发者可以创建自定义 Hook（Custom Hook），用以复用一些逻辑，这些逻辑会成为一个独立的逻辑单元，不再出现在组件树中，但仍然能够响应 React 在渲染之间的变化。</p><ul><li><strong>由 js 的 class 带来的疑惑</strong></li></ul><p>简单来说，就是 js 语法中关于 this 的指向以及原型链、继承这类问题常常会给新手开发者学习 React 带来困惑。比如，在 React 组件内的事件监听之前需要手动绑定 this 的问题。</p><p>为了解决这些问题，Hooks 允许开发者在没有 class 的情况下使用 React 的 features。</p><p>总结来说，推出 Hooks 的动机是解决长时间使用和维护 react 过程中遇到的一些难以避免的问题，如：</p><ol><li>难以重用和共享组件中的与状态相关的逻辑</li><li>逻辑复杂的组件难以开发与维护，当我们的组件需要处理多个互不相关的 local state 时，每个生命周期函数中可能会包含着各种互不相关的逻辑在里面。</li><li>类组件中的 this 增加学习成本，类组件在基于现有工具的优化上存在些许问题。</li><li>由于业务变动，函数组件不得不改为类组件等等。</li></ol><h2 id="Hooks-的规则"><a href="#Hooks-的规则" class="headerlink" title="Hooks 的规则"></a>Hooks 的规则</h2><p>Hooks 仍然是 Javascript 函数，但是在使用时必须遵循两个常规 js 函数不具备的规则：</p><ul><li>只能在顶层调用 Hooks，不要在循环语句、条件判断或嵌套函数中调用 Hooks</li><li>仅从 React 函数式组件中调用 Hooks，不要从常规 js 函数中调用 Hooks</li><li>开发者也可以在 custom hooks 中调用 Hooks。</li></ul><p>遵循了上述规则之后，就能够确保每次组件渲染时都以相同的顺序调用 Hook。</p><p>为此，官方提供了一个名叫 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks" target="_blank" rel="noopener">eslint-plugin-react-hooks</a> 的 eslint 插件用来强制执行上述规则。</p><ol><li>将 eslint-plugin-react-hooks 安装到项目中：</li></ol><p><code>npm install eslint-plugin-react-hooks@next --save-dev</code></p><ol start="2"><li>配置 eslint</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"plugins"</span>: [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"react-hooks"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  ],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"rules"</span>: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"react-hooks/rules-of-hooks"</span>: <span class="string">"error"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="Hooks-API"><a href="#Hooks-API" class="headerlink" title="Hooks API"></a>Hooks API</h2><p>由于 Hooks 是<strong>向后兼容</strong>（Backwards compatiblity, 也叫向下兼容）的，class component 不会被移除，向后兼容的友好性使得开发者可以将项目逐渐迁移到新的 Hooks API。</p><p>Hooks API 主要分为三种：</p><ol><li><strong>State hooks</strong>：在函数式组件中使用 state</li><li><strong>Effect hooks</strong>：在函数式组件中使用 life-cycle 和 side effect</li><li><strong>Custom hooks</strong>：用来复用组件逻辑，解决了上述动机中阐述的第一个问题</li></ol><ul><li><p><strong>State hooks</strong></p><p>看一个例子：</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// TODO 声明一个变量名为 count 的 state</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &lt;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/</span>button&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &lt;<span class="regexp">/div&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">  );</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">&#125;</span></span></pre></td></tr></table></figure><p>在这个例子中，“useState”就是一个 hook，通过它我们可以嵌入组件内部的 state，这个 useState 函数可以返回一个 pair 元组，其中第一个值是对应当前 hook 的 state 值，第二个是定义修改这个 state 的方法。</p><p>其实这个 pair 的两个返回值分别对应的就是 React 中 hooks 之前的 this.state、this.setState。</p><p>那么我们的组件中不可能只用到一个 state 和一个 setState，所以，useState 这个 hook 可以在一个函数组件中多次使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExampleWithManyStates</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 声明多个state变量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> [age, setAge] = useState(<span class="number">28</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> [fruit, setFruit] = useState(<span class="string">"apple"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> [todos, setTodos] = useState([&#123; <span class="attr">text</span>: <span class="string">"React Hooks"</span> &#125;]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>与以前在一个 class component 中只能写一个 state 相比，hooks 就避免了组件的 state 结构过于臃肿，每个 state 能够被单独处理。另外，useState 的写法可读性高，用户一眼就可以看出和 state 相关的两个变量，如上面例子中的[age, setAge]。</p><ul><li><strong>Effect hooks</strong></li><li></li></ul><p>首先了解下什么是 _Side Effect_（副作用），副作用是指函数或表达式的行为依赖于外部环境：</p><ul><li>函数或表达式修改了它的 scope 之外的状态</li><li>函数或表达式除了返回语句之外，还与外部环境或它所调用的函数有交互行为</li></ul><p>Effect hook 为函数式组件添加了执行 side effects 的能力。我们使用 useEffect 这个 API 来处理副作用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 类似于 class component 中的 componentDidMount 和 componentDidUpdate:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 调用浏览器 API 更改文档标题 title</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &lt;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/</span>button&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &lt;<span class="regexp">/div&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">  );</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">&#125;</span></span></pre></td></tr></table></figure><p>React Hooks 解决了在函数式组件中使用 life-cycle 的问题。useEffect Hook 可以看作是 React 类生命周期方法中 componentDidMount、componentDidUpdate 和 componentWillMount 的组合，这个钩子函数类似于 redux 中的 subscrib，每当 React 因为 state 或 props 改变重新 render 之后，就会触发 useEffect 里的回调函数。useEffect 的代码既会在初始化时执行，也会在后续每次 rerender 时执行。</p><ul><li><strong>Custom hooks</strong></li></ul><p>构建自定义钩子函数可以将组件逻辑提取到可重用组件中，即在 hooks 中引用其它 hooks。下面这个官方给出的 demo 演示了一个聊天程序中朋友是否处于在线状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 底层 Hooks, 返回布尔值：是否在线</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFriendStatusBoolean</span>(<span class="params">props</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    setIsOnline(status.isOnline);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    ChatAPI.subscribeToFriendStatus(props.friendID, handleStatusChange);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> isOnline;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上层 Hooks，根据在线状态返回字符串：Loading... or Online or Offline</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFriendStatusString</span>(<span class="params">props</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> isOnline = useFriendStatusBoolean(props.friend.id);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (isOnline === <span class="literal">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="string">"Loading..."</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> isOnline ? <span class="string">"Online"</span> : <span class="string">"Offline"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用了底层 Hooks 的 UI</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendListItem</span>(<span class="params">props</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> isOnline = useFriendStatusBoolean(props.friend.id);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    &lt;li style=&#123;&#123; <span class="attr">color</span>: isOnline ? <span class="string">"green"</span> : <span class="string">"black"</span> &#125;&#125;&gt;&#123;props.friend.name&#125;&lt;<span class="regexp">/li&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">  );</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"><span class="regexp"></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">/</span><span class="regexp">/ 使用了上层 Hooks 的 UI</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">function FriendListStatus(props) &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">  const statu = useFriendStatusString(props.friend.id);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"><span class="regexp"></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">  return &lt;li&gt;&#123;statu&#125;&lt;/</span>li&gt;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>在这个例子中有两个 Hooks：<strong>useFriendStatusBoolean</strong> 与 <strong>useFriendStatusString</strong>，<strong>useFriendStatusString</strong> 是利用 <strong>useFriendStatusBoolean</strong> 生成的新 Hook，因为这两个 Hooks 的数据是联动的，所以可以提供给两个不同的 UI 组件使用：<strong>FriendListItem</strong> 与 <strong>FriendListStatus</strong>，两个 UI 组件的状态也将是联动的。</p><p>值得注意的是：</p><ol><li>这里，<strong>useFriendStatusBoolean 和 useFriendStatusString 是有状态组件</strong>（使用 useState），没有渲染，所以就可以作为 Custom Hooks 被任何 UI 组件所调用，实现了<strong>组件的复用</strong>。</li><li><strong>FriendListItem 和 FriendListStatus 是有渲染的组件</strong>（返回了 JSX），没有状态（没有使用 useState），所以他们就是一个纯 UI 组件。</li></ol><ul><li><strong>Other Built-in Hooks API</strong></li></ul><p>除了上述介绍的 useState、useEffect 之外，还有一些内置的其它 hooks，如：</p><ul><li>useContext：替代了&lt;Context.Consumer&gt;使用 render props 的写法，使组件树更加简洁。</li><li>useReducer：相当于组件自带的 redux reducer，负责接收 dipatch 分发的 action 并更新 state。</li><li>useCallback</li><li>……</li></ul><h2 id="Hooks-FAQ"><a href="#Hooks-FAQ" class="headerlink" title="Hooks FAQ"></a>Hooks FAQ</h2><p>参见官方文档针对 React Hooks 一些常见问题的解答：<br><a href="https://react.css88.com/docs/hooks-faq.html" target="_blank" rel="noopener">https://react.css88.com/docs/hooks-faq.html</a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://react.css88.com/docs/hooks-intro.html" target="_blank" rel="noopener">React 中文文档 - Hooks 概述</a></li><li><a href="https://react.css88.com/docs/hooks-faq.html" target="_blank" rel="noopener">Hooks FAQ</a></li><li><a href="https://juejin.im/post/5be8d3def265da611a476231" target="_blank" rel="noopener">精读《React Hooks》</a></li><li><a href="https://zhuanlan.zhihu.com/p/50921147?utm_source=wechat_timeline&utm_medium=social&utm_oi=27826472353792&from=timeline&isappinstalled=0" target="_blank" rel="noopener">像呼吸一样自然：React Hooks + RxJS</a></li><li><a href="https://zhuanlan.zhihu.com/p/48264713" target="_blank" rel="noopener">对 React Hooks 的一些思考</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在开始本文的探讨之前，先来看看 React 官网 对 Hooks 做出的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ho
      
    
    </summary>
    
    
      <category term="原创" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="技术栈" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Hooks" scheme="https://henery002.github.io/tags/Hooks/"/>
    
  </entry>
  
  <entry>
    <title>项目搭建/配置注意点</title>
    <link href="https://henery002.github.io/2018/08/16/2-3.%20%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BAand%E9%85%8D%E7%BD%AE%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>https://henery002.github.io/2018/08/16/2-3.%20%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BAand%E9%85%8D%E7%BD%AE%E6%B3%A8%E6%84%8F%E7%82%B9/</id>
    <published>2018-08-16T02:00:00.000Z</published>
    <updated>2020-02-16T10:37:10.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leopard"><a href="#Leopard" class="headerlink" title="Leopard"></a>Leopard</h2><p>【注意】：</p><ol><li>当前采用共享文件夹的方式开发，不需要开启相关服务。</li><li>代码位于虚拟机下 <code>/mnt/hgfs/code/leopard</code> 位置，非 <code>/home/...</code></li></ol><hr><h2 id="D-Vault"><a href="#D-Vault" class="headerlink" title="D-Vault"></a>D-Vault</h2><p><strong>项目搭建配置大致流程：</strong></p><ol><li><p>在Linux环境下拉取远程代码<br>在linux下进入到指定目录下，执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">git lfs clone <span class="string">"http://wei.fanguang:datatom.com@211.144.114.26:5088/trunk/d-vault.git"</span></span></pre></td></tr></table></figure><p>从代码线上拉取完整代码（存放在linux环境下）。</p></li><li><p>修改相关配置<br>使用 <code>vi package.json</code> 命令修改以下文件：</p><ol><li><p><code>./webui/package.json</code> 删除 <code>cross-env</code> 前缀【d-vault项目中必须项】</p></li><li><p><code>./webui/dist/api/config.ini.json</code> 配置Linux主机IP（即<code>192.168.3.24</code>）【d-vault项目中必须项】</p></li></ol></li><li><p>导入 <code>node_modules</code> 包（用于开启 npm 服务，必须项，否则无法开启服务）</p></li><li><p>开启 npm 服务<br>在Linux下进入 <code>node-modules</code> 所在目录，开启 npm 服务：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cd /home/code/d-vault-webui/</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">npm start</span></pre></td></tr></table></figure></li><li><p>在浏览器端打开 <code>&quot;http://192.168.3.24:8989/#/home&quot;</code></p></li></ol><p>【注意】：</p><ol><li>进入到虚拟机 <code>/home/code/d-vault/webui</code> 下开启 npm 服务（必须项）<br>若 npm 服务未开启或开启失败，无法访问 <code>192.168.1.221:8989/#/home</code>。开启失败原因可能是 该目录下 <code>node_modules</code> 包的问题。<br>建议先备份该包再重新拷贝到原位置，再次尝试。</li><li>手动修改以下配置文件：<ol><li><code>../webui/package.json</code>                  删除蓝色内容</li><li><code>../webui/dist/api/config.ini.json</code>      配置IP</li><li><code>../webui/src/conf/Conf.js</code>              将IP改为自己的节点 <code>192.168.1.221</code> （貌似不是必须？？？）</li></ol></li></ol><hr><h2 id="demo项目-ant-design-pro："><a href="#demo项目-ant-design-pro：" class="headerlink" title="demo项目 - ant-design-pro："></a>demo项目 - ant-design-pro：</h2><p>【注意】：<br>Linux下：</p><ol><li><code>git clone “http://...ant-design-pro.git”</code>      #从github上拉取源码</li><li><code>npm install</code>                                   #进入到项目目录下安装依赖包</li><li><code>npm start</code>                                     #启动服务<br>【注】：若此时系统中已存在其他项目被启动的npm服务（即192.168.3.24:8000等端口已被占用），<br>则此时系统会询问并自动为当前项目分配一个端口号，用以在浏览器中打开该项目页面，如：</li></ol><hr><h2 id="demo项目"><a href="#demo项目" class="headerlink" title="demo项目"></a>demo项目</h2><p>【注意】：<br>  需进入到项目根目录下开启 npm 服务</p><hr><h2 id="Dana"><a href="#Dana" class="headerlink" title="Dana"></a>Dana</h2><hr><h2 id="signal-tunning（上海交警城市大脑项目）"><a href="#signal-tunning（上海交警城市大脑项目）" class="headerlink" title="signal-tunning（上海交警城市大脑项目）"></a>signal-tunning（上海交警城市大脑项目）</h2><p><strong>项目开发环境：</strong><br>  <code>node 8.9.3</code>、<code>windows</code>（<code>linux</code>下因暂时无法搭建VPN，所以无法开发）</p><p><strong>项目环境搭建大致流程：</strong><br>  由于该项目属于中途接手，所以脚手架之类的环境都已搭好，需要做的就是开启前端服务跑通页面。</p><ol><li>使用<code>Cisco anyconnect（VPN）</code>连接阿里内网；<br>【注意】：VPN的链接需要关闭杀毒软件、防火墙。</li><li><code>npm install</code> 之后，使用 <code>sh honeycomb_start.sh</code> 命令开启服务（也可在<code>package.json</code>中配置使用 npm start 开启服务）<br>【注意】：若 <code>honeycomb_start</code> 命令找不到，可重新安装：<br><code>npm install -g honeycomb-cli@0.2.12</code></li><li>打包：<br><code>sh honeycomb_package.sh</code><br>【注意】：该项目打包之后，貌似会自动删掉一部分东西，所以打包之前慎重，做好备份（貌似assets里的node_modules包会被删掉？）</li></ol><hr><h2 id="PandaBI"><a href="#PandaBI" class="headerlink" title="PandaBI"></a>PandaBI</h2><p><strong>项目开发环境及架构：</strong></p><ol><li><code>linux</code></li><li><code>react</code> + <code>redux</code></li></ol><p><strong>项目开发模式环境搭建：</strong><br>  在clone下来代码线后，<br>     1. <code>npm install</code></p><hr><h2 id="demo项目-create-react-app"><a href="#demo项目-create-react-app" class="headerlink" title="demo项目 - create-react-app"></a>demo项目 - create-react-app</h2><p><strong>项目开发环境及架构：</strong></p><ol><li><code>macOs</code> /<code>iTerm2</code>(bash)</li><li><code>react</code></li></ol><p><strong>项目开发环境搭建流程：</strong></p><ol><li><p><code>github: https://github.com/Henery002/create-react-app</code></p></li><li><p>在目标路径下创建项目工程文件：【注：npx创建项目只是其中一种方式】</p><ol><li><code>npx create-react-app my-app</code></li><li><code>cd my-app</code></li><li><code>npm start</code> / <code>yarn start</code><br>【注】：npx可以理解为npm指令的简化命令，此处可拉取远程Git仓库并在本地创建初始化工程文件<code>app/</code>。它会帮你创建一个 <code>app/</code> 文件夹，并初始化项目文件结构，安装<code>package.json</code>依赖包。无需配置，可以直接到 <code>/src</code> 下编写react代码。</li></ol><p>图示：</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Leopard&quot;&gt;&lt;a href=&quot;#Leopard&quot; class=&quot;headerlink&quot; title=&quot;Leopard&quot;&gt;&lt;/a&gt;Leopard&lt;/h2&gt;&lt;p&gt;【注意】：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当前采用共享文件夹的方式开发，不需要开启相关服务。&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="原创" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="工程搭建" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="开发环境" scheme="https://henery002.github.io/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
      <category term="linux" scheme="https://henery002.github.io/tags/linux/"/>
    
      <category term="npm" scheme="https://henery002.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>日常纠错报错记录（第一篇）</title>
    <link href="https://henery002.github.io/2018/05/29/2-4.%20%E6%97%A5%E5%B8%B8%E7%BA%A0%E9%94%99%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://henery002.github.io/2018/05/29/2-4.%20%E6%97%A5%E5%B8%B8%E7%BA%A0%E9%94%99%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2018-05-29T09:00:00.000Z</published>
    <updated>2021-11-07T13:40:21.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="001-Xshell-无法连接虚拟机"><a href="#001-Xshell-无法连接虚拟机" class="headerlink" title="001 Xshell 无法连接虚拟机"></a>001 Xshell 无法连接虚拟机</h2><blockquote><p>2017.12.26</p></blockquote><ul><li><p><strong>问题描述：</strong></p><p><strong>无法正确连接虚拟机</strong><br>Linux 的 npm 服务可用但网页打不开、Xshell 无法连接虚拟机，linux 无法 ping 主机（ <code>connect: network is unreachable</code>）</p></li><li><p><strong>存在问题：</strong><br><img src="../images/errlogs_01/1.png" alt="1"><br>尚不理解</p></li><li><p><strong>解决方法：</strong></p><p>（由车春旭解决）<br>贴图：–</p></li></ul><hr><h2 id="002-svg-图标的使用方式"><a href="#002-svg-图标的使用方式" class="headerlink" title="002 svg 图标的使用方式"></a>002 svg 图标的使用方式</h2><blockquote><p>2017.12.11</p></blockquote><ul><li><p><strong>问题描述：</strong><br>svg 图标的使用方式</p></li><li><p><strong>使用方式：</strong><br>示例：开发者中心 回到顶部 按钮<br>[注意事项]：需要把<code>.svg</code>静态资源上传到<code>home/code/src/img/image/DevCenter/</code>下<br><img src="../images/errlogs_01/2.png" alt="2"></p></li></ul><h2 id="003-为-D-Vault-开发者中心添加滚动条多次失败"><a href="#003-为-D-Vault-开发者中心添加滚动条多次失败" class="headerlink" title="003 为 D-Vault 开发者中心添加滚动条多次失败"></a>003 为 D-Vault 开发者中心添加滚动条多次失败</h2><blockquote><p>2017.12.01</p></blockquote><ul><li><p><strong>问题描述：</strong><br>为 D-Vault 开发者中心添加滚动条多次失败</p></li><li><p><strong>存在问题：</strong><br>d-valut 中在通用 css 中设置了滚动条 <code>width=0</code>，所以所有页面默认不显示。开发者中心页面设置<code>width=10px</code>无效的原因是该页面布局采用了 <code>position:relative</code> 定位的方式，所以必须设置 <code>right:10px;</code> ，为滚动条留出空间。</p></li><li><p><strong>解决方式：</strong><br>为滚动条父元素设置 <code>right:10px;</code> ，再设置滚动条样式（关于滚动条样式设置，参见 <a href="http://blog.csdn.net/zh_rey/article/details/72473284" target="_blank" rel="noopener">http://blog.csdn.net/zh_rey/article/details/72473284</a> ）：<br><img src="../images/errlogs_01/3.png" alt="3"></p></li></ul><h2 id="004-正则匹配文件后缀名"><a href="#004-正则匹配文件后缀名" class="headerlink" title="004 正则匹配文件后缀名"></a>004 正则匹配文件后缀名</h2><blockquote><p>2017.11.27</p></blockquote><ul><li><p><strong>问题描述：</strong><br>正则匹配文件后缀名</p></li><li><p><strong>解决方式：</strong><br><code>/\.js$/</code> – 以 .js 结尾<br><code>/\.(jps|png)$/</code> – 以 .jpg 或 .png 结尾</p></li></ul><h2 id="005-获取-url-中（或上传的文件）的文件名（去掉后缀名）"><a href="#005-获取-url-中（或上传的文件）的文件名（去掉后缀名）" class="headerlink" title="005 获取 url 中（或上传的文件）的文件名（去掉后缀名）"></a>005 获取 url 中（或上传的文件）的文件名（去掉后缀名）</h2><blockquote><p>2017.11.20 16:00</p></blockquote><ul><li><strong>问题描述：</strong><br>获取 url 中（或上传的文件）的文件名（去掉后缀名）</li><li><strong>存在问题：</strong><br>文件的后缀名种类繁多，此处用正则表达式（<code>/\.(jpg|png|gif|...)/</code>）去匹配不合适，可直接使用<code>lastIndexOf(&#39;.&#39;)</code>等 API。</li><li><strong>解决方式：</strong><ol><li><code>split(&#39;/&#39;);</code> //将 url 分隔成数组，取最后一个元素；</li><li><code>arr.slice(0, array.lastIndexOf(&#39;.&#39;));</code> //查找最后一个.，截取其前所有字符并返回。<br><img src="../images/errlogs_01/5.png" alt="5"></li></ol></li></ul><h2 id="006-通过-git-命令只拉取指定文件夹下的内容"><a href="#006-通过-git-命令只拉取指定文件夹下的内容" class="headerlink" title="006 通过 git 命令只拉取指定文件夹下的内容"></a>006 通过 git 命令只拉取指定文件夹下的内容</h2><blockquote><p>2017.11.15 16:50</p></blockquote><ul><li><p><strong>问题描述：</strong><br>在拉取 git 远程仓库的代码时，可以通过 git 命令只拉取指定文件夹下的内容</p></li><li><p><strong>存在问题：</strong><br>如果只拉取 git 上某仓库的指定文件夹，如 leopard/engine/webui/dana/leopard，可以通过相关命令实现，但存在的问题是 无法在该目录下切换分支，它会默认使用 master 分支。所以，该思路不可行。</p><p>命令：</p><ol><li><code>git init</code></li><li><code>git remote add -f origin &quot;http://211.144.114.26:5081/trunk/leopard.git&quot;</code></li><li><code>git config core.sparsecheckout true</code></li><li><code>echo &quot;engine/webui/dana/leopard&quot; &gt;&gt; .git/info/sparse-checkout</code></li><li><code>git pull origin master</code></li></ol><p>参考文章：<a href="http://blog.csdn.net/linlzk/article/details/49019787" target="_blank" rel="noopener">http://blog.csdn.net/linlzk/article/details/49019787</a></p></li></ul><h2 id="007-无法打开页面问题"><a href="#007-无法打开页面问题" class="headerlink" title="007 无法打开页面问题"></a>007 无法打开页面问题</h2><blockquote><p>2017.11.15 14:39 <strong>无法打开页面问题</strong></p></blockquote><ul><li><p><strong>问题描述：</strong><br>E 盘下共享文件夹<code>code/leopard</code>无法同步到 linux 开发环境下（<code>/home/...</code>），并且<code>192.168.1.221</code>节点无法打开页面（报<code>502 bad gateway</code>）</p></li><li><p><strong>错误原因：</strong></p><ol><li>在设置了共享文件夹（<code>e/code/leopard</code>）的方式之后，开发环境的代码包不再位于 linux 下的 <code>/home/</code> 中，而是位于 /<code>mnt/hgfs/code/leopard</code> 下。切记！<br>所以并非无法实现同步，而是之前认为的位置是错误的。</li><li>502 的错误：apache 服务未打开。</li></ol></li><li><p><strong>解决方式：</strong><br>该 502 错误不同于昨天遇到的 502：昨天报 502 是因为在文件上传提交 ajax 时，发送了错误的地址（默认发送了本地 host，即<code>window.location.host</code>，而是应该在测试的时候，发送<code>192.168.1.20</code>的地址，在提交代码的时候，再改回<code>window.location.host</code>）。<br><img src="../images/errlogs_01/7_1.png" alt="7-1"></p><p>打开 apache 服务：（至于 apache 服务为什么被关闭了，i d’ont know.）<br><img src="../images/errlogs_01/7_2.png" alt="7-2"><br><img src="../images/errlogs_01/7_3.png" alt="7-3"></p></li></ul><h2 id="008-开启-npm-服务失败问题"><a href="#008-开启-npm-服务失败问题" class="headerlink" title="008 开启 npm 服务失败问题"></a>008 开启 npm 服务失败问题</h2><blockquote><p>2018.01.11 12:20 <strong>开启 npm 服务失败问题</strong></p></blockquote><ul><li><p><strong>问题描述：</strong><br>d-vault 项目在虚拟机 <code>/home/code/d-vault/webui</code> 目录下开启 npm 服务失败</p></li><li><p><strong>错误原因：</strong><br>目测很可能是因为该目录下 <code>node_modules</code> 包的问题<br><img src="../images/errlogs_01/8_1.png" alt="8"></p></li><li><p><strong>解决方式：</strong><br>可以尝试将项目备份，然后重新将 <code>node_modules</code> 包拷贝一份替换</p></li></ul><h2 id="008-1-git-push-推送失败问题"><a href="#008-1-git-push-推送失败问题" class="headerlink" title="008-1 git push 推送失败问题"></a>008-1 git push 推送失败问题</h2><blockquote><p>2018.01.29 14:10 <strong>git push 推送失败问题</strong></p></blockquote><ul><li><p><strong>问题描述：</strong><br><code>git push</code> 提交代码时，因 add 了新图片文件导致文件过大，无法推送。<br><img src="../images/errlogs_01/8_1_1.png" alt="8-1"></p></li><li><p><strong>错误原因：</strong><br>（推测是新增文件无法连接到上海远程服务器）</p></li><li><p><strong>解决方式：</strong><br>方式一：使用 <code>git lfs push</code> 推送，无效；<br>方式二：在重新执行 <code>git push</code> 之前，先执行：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">[root@localhost webui]# iptables -t nat -A OUTPUT -d 192.168.50.4 -j DNAT --to-destination 211.144.114.26</span></pre></td></tr></table></figure><pre><code>再执行 `git push` ，成功。![8-2](../images/errlogs_01/8_1_2.png)</code></pre><h2 id="009-使用-git-push-命令时需反复输入用户名的问题"><a href="#009-使用-git-push-命令时需反复输入用户名的问题" class="headerlink" title="009 使用 git push 命令时需反复输入用户名的问题"></a>009 使用 git push 命令时需反复输入用户名的问题</h2><blockquote><p>2018.01.29 14:22 <strong>使用 git push 命令时需反复输入用户名的问题</strong></p></blockquote><ul><li><p><strong>问题描述：</strong><br>使用 <code>git pull</code> 或 <code>git push</code> 命令时每次都需要输入冗长的用户名和密码</p></li><li><p><strong>错误原因：</strong><br>在 <code>git clone &quot;...&quot;</code> 拉取代码库的时候，未将用户名和密码一起设置进去</p></li><li><p><strong>解决方式：</strong><br>使用 <code>git clone</code> 命令重新拉取代码库时将用户名和密码一起设置进去<br>=&gt; <code>git clone http://username:password@giturl/xxx.git</code></p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">[root@localhost webui]# git lfs clone "http://wei.fanguang:datatom.com@211.144.114.26:5081/trunk/d-vault.git"</span></pre></td></tr></table></figure><p><img src="../images/errlogs_01/9_1.png" alt="9"></p><h2 id="010-拉取源代码时图片未成功下载，导致本地图片无法打开，页面图片不显示"><a href="#010-拉取源代码时图片未成功下载，导致本地图片无法打开，页面图片不显示" class="headerlink" title="010 拉取源代码时图片未成功下载，导致本地图片无法打开，页面图片不显示"></a>010 拉取源代码时图片未成功下载，导致本地图片无法打开，页面图片不显示</h2><blockquote><p>2018.02.01 15:00 <strong>拉取源代码时图片未成功下载，导致本地图片无法打开，页面图片不显示</strong></p></blockquote><ul><li><p><strong>问题描述：</strong><br><code>git clone</code>在拉取源代码时未能成功将图片大文件<code>pull</code>下来，于是跳过该过程，导致本地（<code>linux</code>下）图片无法正常显示</p></li><li><p><strong>错误原因：</strong><br><code>lfs</code>问题。…</p></li><li><p><strong>解决方式：</strong><br>[<strong>法一</strong>]踩过两次雷区的一种方法：<br>先删除本地（<code>linux</code>下）图片文件，再重新<code>download</code>远程文件。</p><ol><li>使用 <code>rm -rf books</code> 命令删除<code>books</code>目录及其目录下所有图片；</li><li>使用 <code>git checkout -- books</code> 撤销删除操作，即重新下载已被删除的文件。但此处由于 <code>lfs</code> 的问题导致无法正常<code>download</code>。需要先执行 <code>iptables</code> 命令：</li></ol></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">iptables -t nat -A OUTPUT -d 192.168.50.4 -j DNAT --to-destination 211.144.114.26 #后改为 192.168.50.2 、211.144.114.26:5088</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">（iptables -t nat -F  &amp;&amp; iptables -t nat -A OUTPUT -p tcp -d <span class="number">192.168</span><span class="number">.50</span><span class="number">.2</span> --dport <span class="number">80</span> -j DNAT --to <span class="number">211.144</span><span class="number">.114</span><span class="number">.26</span>:<span class="number">5088</span> ）  -- 张忠宝荐</span></pre></td></tr></table></figure><p>再接着执行 <code>git checkout -- books</code> 命令，便可成功重新下载被删除文件。<br><img src="../images/errlogs_01/10_1.png" alt="10-1"></p><p>[<strong>法二</strong>]（法一后来发现不再生效）：<br>进入到图片所在文件夹下，删除所有图片，再重新 <code>checkout</code> 撤回删除，便重新下载。</p><ol><li><code>cd img/images/DevCenter/Books</code></li><li><code>ll</code> #列出所有图片，或 <code>ls -l</code></li><li><code>rm -rf *</code> #删除所有图片</li><li><code>git checkout -- *</code> #撤回删除，重新下载<br><img src="../images/errlogs_01/10_2.png" alt="10-2"></li></ol><p>[<strong>法三</strong>]（同法二）：<br>可在根目录下执行，也可在指定目录下执行操作：</p><ol><li>删除所有指定类型的文件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">"*.png"</span> -type f -print -exec rm -rf &#123;&#125; \;</span></pre></td></tr></table></figure><p><img src="../images/errlogs_01/10_3.png" alt="10-3"></p><ol start="2"><li>重新下载（即撤回删除操作）。若下载缓慢，可终止插入执行 <code>iptables</code> …… 命令再重新 <code>checkout</code><br><code>git checkout &quot;*.png&quot;</code> 或 <code>git checkout -- &quot;*.png&quot;</code><br><img src="../images/errlogs_01/10_4.png" alt="10-4"></li></ol><h2 id="011-多分支提交时失败报错的问题"><a href="#011-多分支提交时失败报错的问题" class="headerlink" title="011 多分支提交时失败报错的问题"></a>011 多分支提交时失败报错的问题</h2><blockquote><p>2018.02.09 10:50 <strong>多分支提交时失败报错的问题</strong></p></blockquote><ul><li><p><strong>问题描述：</strong><br>使用 <code>git cherry-pick</code> 指令进行多分支提交时报错失败，无法在当前分支提交另一分支已经提交的代码<br>具体过程如下：</p><ol><li>在 <code>master</code> 分支正常提交一次记录</li><li>切换到 <code>v3.5.2</code> 分支上（先<code>pull</code>代码），使用 <code>cherry-pick e7a58f2b</code> 在 <code>v3.5.2</code> 上提交 <code>master</code> 上的刚才的记录</li><li>在 <code>v3.5.2</code> 上 <code>git push</code> 推送代码，发现报错，推送失败。<br><img src="../images/errlogs_01/11_1.png" alt="11-2"></li></ol></li><li><p><strong>错误原因：</strong><br>尚不清晰，可能是冲突的原因</p></li><li><p><strong>解决方式：</strong><br>尚未整理出完整可行的方式，可尝试以下方法：<br><img src="../images/errlogs_01/11_2.png" alt="11-2"></p></li></ul><h2 id="012-git-pull-拉取代码时提示有错误（-git-ORIG-HEAD文件问题）"><a href="#012-git-pull-拉取代码时提示有错误（-git-ORIG-HEAD文件问题）" class="headerlink" title="012 git pull 拉取代码时提示有错误（.git/ORIG_HEAD文件问题）"></a>012 git pull 拉取代码时提示有错误（<code>.git/ORIG_HEAD</code>文件问题）</h2><blockquote><p>2018.03.06 11:11 <strong>git pull 拉取代码时提示有错误（<code>.git/ORIG_HEAD</code>文件问题）</strong></p></blockquote><ul><li><p><strong>问题描述：</strong><br>在 <code>git pull</code> 拉取代码时提示错误，导致无法正常拉取。<br><img src="../images/errlogs_01/12_1.png" alt="12-1"></p></li><li><p><strong>错误原因：</strong><br>参考：<a href="https://stackoverflow.com/questions/10570319/cannot-pull-git-cannot-resolve-reference-orig-head" target="_blank" rel="noopener">https://stackoverflow.com/questions/10570319/cannot-pull-git-cannot-resolve-reference-orig-head</a><br><img src="../images/errlogs_01/12_2.png" alt="12-2"></p></li><li><p><strong>解决方式：</strong><br>在项目目录中找到 <code>ORIG_HEAD</code> 文件，删除</p><ol><li><code># find / -name ORIG_HEAD</code><br><code>/home/code/d-vault/.git/ORIG_HEAD</code></li><li><code># rm -rf ORIG_HEAD</code></li><li><code># git pull</code> # 重新拉取，成功</li></ol></li></ul><h2 id="013-linux-下-npm-start-启动成功，但无法打开网页"><a href="#013-linux-下-npm-start-启动成功，但无法打开网页" class="headerlink" title="013 linux 下 npm start 启动成功，但无法打开网页"></a>013 linux 下 npm start 启动成功，但无法打开网页</h2><blockquote><p>2018.03.21 12:00 <strong>linux 下 npm start 启动成功，但无法打开网页</strong></p></blockquote><ul><li><p><strong>问题描述：</strong><br>在 <code>d-vault</code> / <code>Dana4.0</code> 项目中开启 npm 服务（<code>npm start</code>）成功后，无法正常打开网页<br>（<code>linux</code>在前几天重新创建过虚拟机，可能是相关配置未配置好？）<br><img src="../images/errlogs_01/13_1.png" alt="13-1"></p></li><li><p><strong>错误原因：</strong><br>未关闭防火墙（车春旭解决认为）</p></li><li><p><strong>解决方式：</strong><br>关闭防火墙：<br><code># systemctl stop firewalld</code><br><code># systemctl disable firewalld</code><br><img src="../images/errlogs_01/13_2.png" alt="13-2"></p></li></ul><h2 id="014-Dana4-0-中无法通过-js-操作-iframe-中的元素"><a href="#014-Dana4-0-中无法通过-js-操作-iframe-中的元素" class="headerlink" title="014 Dana4.0 中无法通过 js 操作 iframe 中的元素"></a>014 Dana4.0 中无法通过 js 操作 iframe 中的元素</h2><blockquote><p>2018.05.02 17:00 <strong>Dana4.0 中无法通过 js 操作 iframe 中的元素</strong></p></blockquote><ul><li><p><strong>问题描述：</strong><br>解决方案模块中企图通过 js 获取<code>iframe</code>页面中的<code>dom</code>元素以更改其样式，多方尝试后失败</p></li><li><p><strong>错误原因：</strong><br>因此处<code>iframe</code>使用了其他链接的页面，所以这里存在跨域问题，导致暂无法跨域操作<code>dom</code><br><img src="../images/errlogs_01/14_1.png" alt="14-1"><br><img src="../images/errlogs_01/14_2.png" alt="14-2"></p></li><li><p><strong>解决方式：</strong><br>无。暂放弃此需求。<br>参考文章：知乎：js 怎么跨域获取 iframe 中的内容？<a href="https://www.zhihu.com/question/37185579" target="_blank" rel="noopener">https://www.zhihu.com/question/37185579</a></p></li></ul><h2 id="015-Dana4-0-在-beta2-分支中-git-pull-报错无法进行"><a href="#015-Dana4-0-在-beta2-分支中-git-pull-报错无法进行" class="headerlink" title="015 Dana4.0 在 beta2 分支中 git pull 报错无法进行"></a>015 Dana4.0 在 beta2 分支中 git pull 报错无法进行</h2><blockquote><p>2018.05.15 12:00 <strong>Dana4.0 在 beta2 分支中 git pull 报错无法进行</strong></p></blockquote><ul><li><p><strong>问题描述：</strong><br>dana 在本地创建了新分支 beta2 并推送到远程之后，再次在 beta2 分支上<code>git pull</code>时出现问题，无法继续<code>pull</code><br><img src="../images/errlogs_01/15_1.png" alt="15-1"></p></li><li><p><strong>错误原因：</strong><br>暂未知</p></li><li><p><strong>解决方式：</strong><br>执行上图红色部分命令，为<code>beta2</code> 分支创建跟踪信息</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ git branch --<span class="keyword">set</span>-upstream-to=origin/beta2 beta2</span></pre></td></tr></table></figure><p><img src="../images/errlogs_01/15_2.png" alt="15-2"><br>重新 <code>git pull</code> ，成功。</p><h2 id="016-Dana4-0-beta2-中模拟页面长时间无操作后用户登出功能"><a href="#016-Dana4-0-beta2-中模拟页面长时间无操作后用户登出功能" class="headerlink" title="016 Dana4.0 beta2 中模拟页面长时间无操作后用户登出功能"></a>016 Dana4.0 beta2 中模拟页面长时间无操作后用户登出功能</h2><blockquote><p>2018.05.29 17:00 <strong>Dana4.0 beta2 中模拟页面长时间无操作后用户登出功能</strong></p></blockquote><ul><li><p><strong>解决方式：</strong><br><strong><em>思路一：</em></strong></p><ol><li>登陆成功时将当前时间 <code>currentTime</code> 存储到 <code>localStorage</code> ；</li><li>页面在 <code>componentDidMount</code> 中（即刷新）时，重新获取当前时间 <code>currentTime</code> ，与 <code>localStorage</code> 中的 <code>loginTime</code> 作比较，超出 <code>duration</code> 则登出。<br>缺点：效果被写死，无法实现用户无操作才能登出，只能实现网页每隔 <code>duration</code> 后强制登出。否决！<br><img src="../images/errlogs_01/16_1.png" alt="16-1"></li></ol><p><strong><em>思路二：</em></strong></p><ol><li>记录鼠标最后一次操作 <code>mousemove</code> 时的时间 <code>lastMove；</code></li><li>每隔 5 秒检查当前时间 <code>currentTime</code> 与 <code>lastMove</code> 的差值，超出 <code>duration</code> 则登出；</li><li>若新页面暂无鼠标操作，则 <code>lastMove</code> 默认取当前时间。<br>备注：这种方式可以解决思路一存在的问题，实现页面长时间无操作后用户登出功能。但是由于频繁的检查操作，可能会降低性能。暂可用。<br><img src="../images/errlogs_01/16_2.png" alt="16-2"></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;001-Xshell-无法连接虚拟机&quot;&gt;&lt;a href=&quot;#001-Xshell-无法连接虚拟机&quot; class=&quot;headerlink&quot; title=&quot;001 Xshell 无法连接虚拟机&quot;&gt;&lt;/a&gt;001 Xshell 无法连接虚拟机&lt;/h2&gt;&lt;blockquo
      
    
    </summary>
    
    
      <category term="原创" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="错误日志" scheme="https://henery002.github.io/categories/%E5%8E%9F%E5%88%9B/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="笔记" scheme="https://henery002.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="纠错日志" scheme="https://henery002.github.io/tags/%E7%BA%A0%E9%94%99%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
</feed>
